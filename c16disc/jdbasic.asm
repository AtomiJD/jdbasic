; w65c02 assembly code for 'jdbasic'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2024-07-10T09:16:45
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=FLOATSAFE

.cpu  'w65c02'
.enc  'none'
P8ZP_SCRATCH_B1 = 122
P8ZP_SCRATCH_REG = 123
P8ZP_SCRATCH_W1 = 124    ; word
P8ZP_SCRATCH_W2 = 126    ; word
.weak
.endweak
; ---- basic program with sys call ----
* = $0801
	.word  (+), 2024
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint	; assembly code starts here
	jsr  sys.init_system_phase2
	; zeropage is clobbered so we need to reset the machine at exit
	lda  #>sys.reset_system
	pha
	lda  #<sys.reset_system
	pha
	jsr  p8b_main.p8s_start
	jmp  sys.cleanup_at_exit

; ---- block: 'p8b_main' ----
p8b_main	.proc
p8v_pcode 	= 34 	; zp UWORD
	p8c_mend = $9eff

; non-zeropage variables without initialization value
	.section BSS
p8v_bgcolor	.byte  ?
p8v_fgcolor	.byte  ?
p8v_fstack	.word  ?
p8v_fstack1	.word  ?
p8v_graphmode	.byte  ?
p8v_linenr	.word  ?
p8v_pend	.word  ?
p8v_prgptr	.word  ?
p8v_trace	.byte  ?
	.send BSS
; non-zeropage variables
p8v_buffer	; ISO:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00
p8v_filename	; ISO:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00
p8v_lineinput	; ISO:"????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $00


p8s_start	.proc
; program startup initialization
	cld
	tsx
	stx  prog8_lib.orig_stackpointer    ; required for sys.exit()
	.if  prog8_bss_section_size>0
	; reset all variables in BSS section to zero
	lda  #<prog8_bss_section_start
	ldy  #>prog8_bss_section_start
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldx  #<prog8_bss_section_size
	ldy  #>prog8_bss_section_size
	lda  #0
	jsr  prog8_lib.memset
	.endif
	jsr  p8b_main.prog8_init_vars
	jsr  diskio.prog8_init_vars
	jsr  p8b_graphics.prog8_init_vars
	jsr  p8b_runlang.prog8_init_vars
	jsr  p8b_error.prog8_init_vars
	jsr  p8b_jdstr.prog8_init_vars
	jsr  p8b_jdheap.prog8_init_vars
	jsr  p8b_jdvars.prog8_init_vars
	jsr  p8b_jdstrvars.prog8_init_vars
	jsr  p8b_jdarrvars.prog8_init_vars
	jsr  p8b_jdlocal.prog8_init_vars
	jsr  p8b_labels.prog8_init_vars
	jsr  p8b_jdfunc.prog8_init_vars
	jsr  p8b_ifstack.prog8_init_vars
	jsr  p8b_funcstack.prog8_init_vars
	jsr  p8b_forstack.prog8_init_vars
	jsr  p8b_varstack.prog8_init_vars
	jsr  p8b_callstack_b.prog8_init_vars
	jsr  p8b_callstack_w.prog8_init_vars
+        
	clv
	clc
; statements
	stz  p8v_e
	jsr  p8b_main.p8s_init_screen
	jsr  p8b_main.p8s_init_system
	jsr  p8b_main.p8s_init_basic
p8l_label_1_repeat
	jsr  p8b_error.p8s_clear
	lda  #<p8b_main.p8v_lineinput
	ldy  #>p8b_main.p8v_lineinput
	sta  cx16.r0
	sty  cx16.r0+1
	lda  #<$a0
	sta  cx16.r1
	lda  #>$a0
	sta  cx16.r1+1
	
	lda  #0
	jsr  sys.memset
	ldy  #>p8b_main.p8v_lineinput
	lda  #<p8b_main.p8v_lineinput
	jsr  txt.input_chars
	lda  #13
	jsr  txt.chrout
	ldy  #>p8b_main.p8v_lineinput
	lda  #<p8b_main.p8v_lineinput
	jsr  string.strip
	lda  #<p8b_main.p8v_lineinput
	ldy  #>p8b_main.p8v_lineinput
	sta  p8b_main.p8s_tokenize.p8v_rprgptr
	sty  p8b_main.p8s_tokenize.p8v_rprgptr+1
	lda  p8b_main.p8v_pend
	ldy  p8b_main.p8v_pend+1
	sta  p8b_main.p8s_tokenize.p8v_pcodebase
	sty  p8b_main.p8s_tokenize.p8v_pcodebase+1
	jsr  p8b_main.p8s_tokenize
	sta  p8v_e
	lda  p8b_error.p8v_number
	beq  label_asm_2_else
	jsr  p8b_error.p8s_print
	bra  label_asm_1_afterif
label_asm_2_else
	lda  p8v_e
	bne  label_asm_3_afterif
	jsr  p8b_main.p8s_runl
label_asm_3_afterif
label_asm_1_afterif
	bra  p8l_label_1_repeat
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_e	.byte  ?
	.send BSS
	.pend

p8s_init_basic	.proc
; statements
	ldy  #>prog8_interned_strings.string_1
	lda  #<prog8_interned_strings.string_1
	jsr  txt.print
	lda  #13
	jmp  txt.chrout
; variables
	.section BSS
	.send BSS

	.pend

p8s_init_system	.proc
; statements
	stz  p8v_mem
	stz  p8v_mem+1
	; inlined routine follows: progend
            lda  #<prog8_program_end
            ldy  #>prog8_program_end
	; inlined routine end: progend
	sta  p8b_main.p8v_pend
	sty  p8b_main.p8v_pend+1
	ldy  #>prog8_interned_strings.string_2
	lda  #<prog8_interned_strings.string_2
	jsr  txt.print
	ldy  p8b_main.p8v_pend+1
	lda  p8b_main.p8v_pend
	sec
	jsr  txt.print_uwhex
	lda  #13
	jsr  txt.chrout
	ldy  #>prog8_interned_strings.string_3
	lda  #<prog8_interned_strings.string_3
	jsr  txt.print
	ldy  p8b_main.p8v_pend+1
	lda  p8b_main.p8v_pend
	clc
	adc  #<$a0
	tax
	tya
	adc  #>$a0
	tay
	txa
	sec
	jsr  txt.print_uwhex
	lda  #13
	jsr  txt.chrout
	lda  p8b_main.p8v_pend
	ldy  p8b_main.p8v_pend+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pend
	sta  P8ZP_SCRATCH_W1
	lda  p8b_main.p8v_pend+1
	sta  P8ZP_SCRATCH_W1+1
	ldy  #>-$6101
	lda  #<-$6101
	sec
	sbc  P8ZP_SCRATCH_W1
	tax
	tya
	sbc  P8ZP_SCRATCH_W1+1
	tay
	txa
	sta  p8v_mem
	sty  p8v_mem+1
	ldy  #>prog8_interned_strings.string_4
	lda  #<prog8_interned_strings.string_4
	jsr  txt.print
	ldy  p8v_mem+1
	lda  p8v_mem
	jsr  txt.print_uw
	lda  #13
	jsr  txt.chrout
	stz  p8b_main.p8v_trace
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_mem	.word  ?
	.send BSS
	.pend

p8s_init_screen	.proc
; statements
	lda  #5
	ldy  #0
	jsr  txt.color2
	lda  #15
	jsr  cbm.CHROUT
	lda  #$93
	jsr  txt.chrout
	ldy  #>prog8_interned_strings.string_5
	lda  #<prog8_interned_strings.string_5
	jsr  txt.print
	lda  #13
	jsr  txt.chrout
	ldy  #>prog8_interned_strings.string_6
	lda  #<prog8_interned_strings.string_6
	jsr  txt.print
	lda  #13
	jmp  txt.chrout
; variables
	.section BSS
	.send BSS

	.pend

p8s_parse	.proc
; statements
	stz  p8v_lp
	stz  p8v_lp+1
	stz  p8v_p
	stz  p8v_flag
	stz  p8v_basic_cmd
	stz  p8v_basic_cmd+1
	stz  p8v_prevptr
	stz  p8v_prevptr+1
	lda  #<prog8_interned_strings.string_7
	ldy  #>prog8_interned_strings.string_7
	sta  cx16.r0
	sty  cx16.r0+1
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  sys.internal_stringcopy
p8l_label_9_repeat
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	bne  label_asm_4_afterif
	lda  #$7f
	rts
label_asm_4_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	pha
	lda  #<p8v_auto_heap_value_1
	ldy  #>p8v_auto_heap_value_1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_5_afterif
	lda  #$19
	rts
label_asm_5_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isspace
	bcc  p8l_label_143_celse
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	bra  p8l_label_2_cont
p8l_label_143_celse
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_prog8_subexprvar_1
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_prog8_subexprvar_2
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_prog8_subexprvar_3
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isdigit
	lda  #0
	rol  a
	bne  label_asm_6_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #36
	bne  label_asm_10_else
  lda  #1
	bra  label_asm_9_afterif
label_asm_10_else
  lda  #0
label_asm_9_afterif
	bne  label_asm_8_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #37
	bne  label_asm_12_else
  lda  #1
	bra  label_asm_11_afterif
label_asm_12_else
  lda  #0
label_asm_11_afterif
label_asm_8_shortcut
	beq  label_asm_7_shortcut
	lda  p8v_prog8_subexprvar_1
	jsr  string.isdigit
	lda  #0
	rol  a
	bne  label_asm_18_shortcut
	lda  p8v_prog8_subexprvar_1
	cmp  #65
	bne  label_asm_20_else
  lda  #1
	bra  label_asm_19_afterif
label_asm_20_else
  lda  #0
label_asm_19_afterif
label_asm_18_shortcut
	bne  label_asm_17_shortcut
	lda  p8v_prog8_subexprvar_2
	cmp  #66
	bne  label_asm_22_else
  lda  #1
	bra  label_asm_21_afterif
label_asm_22_else
  lda  #0
label_asm_21_afterif
label_asm_17_shortcut
	bne  label_asm_16_shortcut
	lda  p8v_prog8_subexprvar_2
	cmp  #67
	bne  label_asm_24_else
  lda  #1
	bra  label_asm_23_afterif
label_asm_24_else
  lda  #0
label_asm_23_afterif
label_asm_16_shortcut
	bne  label_asm_15_shortcut
	lda  p8v_prog8_subexprvar_3
	cmp  #68
	bne  label_asm_26_else
  lda  #1
	bra  label_asm_25_afterif
label_asm_26_else
  lda  #0
label_asm_25_afterif
label_asm_15_shortcut
	bne  label_asm_14_shortcut
	lda  p8v_prog8_subexprvar_3
	cmp  #69
	bne  label_asm_28_else
  lda  #1
	bra  label_asm_27_afterif
label_asm_28_else
  lda  #0
label_asm_27_afterif
label_asm_14_shortcut
	bne  label_asm_13_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	lda  (P8ZP_SCRATCH_W2),y
	cmp  #70
	bne  label_asm_30_else
  lda  #1
	bra  label_asm_29_afterif
label_asm_30_else
  lda  #0
label_asm_29_afterif
label_asm_13_shortcut
label_asm_7_shortcut
label_asm_6_shortcut
	beq  label_asm_31_afterif
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
p8l_label_3_untilloop
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	pha
	lda  #<p8b_consts.p8v_DELIMITERCHAR
	ldy  #>p8b_consts.p8v_DELIMITERCHAR
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #16
	jsr  prog8_lib.containment_bytearray
	bne  label_asm_34_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #13
	bne  label_asm_36_else
  lda  #1
	bra  label_asm_35_afterif
label_asm_36_else
  lda  #0
label_asm_35_afterif
label_asm_34_shortcut
	bne  label_asm_33_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #10
	bne  label_asm_38_else
  lda  #1
	bra  label_asm_37_afterif
label_asm_38_else
  lda  #0
label_asm_37_afterif
label_asm_33_shortcut
	bne  label_asm_32_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	beq  +
	lda  #1
+                           eor  #1
label_asm_32_shortcut
	beq  p8l_label_3_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  #$2c
	rts
label_asm_31_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  p8b_main.p8s_singlechar
	sta  p8v_p
	cmp  #27
	bne  label_asm_39_afterif
p8l_label_4_untilloop
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	pha
	lda  #<p8v_auto_heap_value_2
	ldy  #>p8v_auto_heap_value_2
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_4_untilloop
	bra  p8l_label_5_cont
label_asm_39_afterif
	lda  p8v_p
	beq  label_asm_40_afterif
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8v_p
	rts
label_asm_40_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #34
	bne  label_asm_41_afterif
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
p8l_label_6_untilloop
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	pha
	lda  #<p8v_auto_heap_value_3
	ldy  #>p8v_auto_heap_value_3
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #4
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_6_untilloop
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #34
	bne  label_asm_43_else
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  #$2d
	rts
label_asm_43_else
	lda  #1
	jsr  p8b_error.p8s_set
	lda  #$7f
	rts
label_asm_42_afterif
label_asm_41_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcc  p8l_label_145_celse
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #33
	bne  label_asm_44_afterif
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	pha
	lda  #<p8b_consts.p8v_DELIMITERCHAR
	ldy  #>p8b_consts.p8v_DELIMITERCHAR
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #16
	jsr  prog8_lib.containment_bytearray
	sta  p8v_flag
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	pha
	lda  #<p8v_auto_heap_value_4
	ldy  #>p8v_auto_heap_value_4
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_45_afterif
	lda  #1
	sta  p8v_flag
label_asm_45_afterif
	lda  p8b_main.p8v_prgptr
	bne  +
	dec  p8b_main.p8v_prgptr+1
+                           dec  p8b_main.p8v_prgptr
	lda  p8v_flag
	beq  label_asm_46_afterif
	lda  #<prog8_interned_strings.string_7
	ldy  #>prog8_interned_strings.string_7
	sta  cx16.r0
	sty  cx16.r0+1
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  sys.internal_stringcopy
	lda  #$2e
	rts
label_asm_46_afterif
label_asm_44_afterif
	lda  p8b_main.p8v_prgptr
	bne  +
	dec  p8b_main.p8v_prgptr+1
+                           dec  p8b_main.p8v_prgptr
p8l_label_145_celse
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcc  p8l_label_147_celse
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  p8v_prevptr
	sty  p8v_prevptr+1
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
p8l_label_7_untilloop
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcs  p8l_label_7_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_statements.p8s_get
	sta  p8v_basic_cmd
	sty  p8v_basic_cmd+1
	ora  p8v_basic_cmd+1
	beq  label_asm_47_afterif
	lda  #<prog8_interned_strings.string_7
	ldy  #>prog8_interned_strings.string_7
	sta  cx16.r0
	sty  cx16.r0+1
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  sys.internal_stringcopy
	lda  p8v_basic_cmd
	rts
label_asm_47_afterif
	lda  p8v_prevptr
	ldy  p8v_prevptr+1
	sta  p8b_main.p8v_prgptr
	sty  p8b_main.p8v_prgptr+1
p8l_label_147_celse
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcc  p8l_label_149_celse
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
p8l_label_8_untilloop
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	lda  #0
	rol  a
	bne  label_asm_49_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isdigit
	lda  #0
	rol  a
label_asm_49_shortcut
	bne  label_asm_48_shortcut
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #95
	bne  label_asm_51_else
  lda  #1
	bra  label_asm_50_afterif
label_asm_51_else
  lda  #0
label_asm_50_afterif
label_asm_48_shortcut
	bne  p8l_label_8_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #36
	bne  label_asm_52_afterif
	lda  #$35
	rts
label_asm_52_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #91
	bne  label_asm_53_afterif
	lda  #$34
	rts
label_asm_53_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #40
	bne  label_asm_54_afterif
	lda  #$47
	rts
label_asm_54_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #64
	bne  label_asm_55_afterif
	lda  #$d7
	rts
label_asm_55_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #35
	bne  label_asm_56_afterif
	lda  #$32
	rts
label_asm_56_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #37
	bne  label_asm_57_afterif
	lda  #$30
	rts
label_asm_57_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #38
	bne  label_asm_58_afterif
	lda  #$31
	rts
label_asm_58_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #33
	bne  label_asm_59_afterif
	lda  #$2f
	rts
label_asm_59_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #58
	bne  label_asm_60_afterif
	lda  #$16
	rts
label_asm_60_afterif
	lda  #$44
	rts
p8l_label_149_celse
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  #0
	rts
p8l_label_2_cont
p8l_label_5_cont
	bra  p8l_label_9_repeat
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_basic_cmd	.word  ?
p8v_flag	.byte  ?
p8v_lp	.word  ?
p8v_p	.byte  ?
p8v_prevptr	.word  ?
p8v_prog8_subexprvar_1	.byte  ?
p8v_prog8_subexprvar_2	.byte  ?
p8v_prog8_subexprvar_3	.byte  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_1	.byte  $0a, $0d
p8v_auto_heap_value_2	.byte  $00, $0a, $0d
p8v_auto_heap_value_3	.byte  $00, $0a, $0d, $22
p8v_auto_heap_value_4	.byte  $00, $0a
	.pend

p8s_tokenize	.proc
; statements
	stz  p8v_t1
	stz  p8v_t1+1
	stz  p8v_strb
	stz  p8v_strb+1
	stz  p8v_val
	stz  p8v_val+1
	stz  p8v_index
	stz  p8v_lp
	stz  p8v_lp+1
	stz  p8v_infuncheader
	stz  p8v_paramcount
	stz  p8v_p_funcno
	stz  p8v_token
	lda  p8v_pcodebase
	ldy  p8v_pcodebase+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8v_rprgptr
	ldy  p8v_rprgptr+1
	sta  p8b_main.p8v_prgptr
	sty  p8b_main.p8v_prgptr+1
p8l_label_14_untilloop
	jsr  p8b_main.p8s_parse
	sta  p8v_token
	lda  p8v_token
	beq  p8l_label_13_after
	lda  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_strb
	sty  p8v_strb+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	beq  label_asm_62_else
	lda  p8v_token
	cmp  #45
	bne  label_asm_64_else
p8l_label_10_untilloop
	lda  p8v_strb
	ldy  p8v_strb+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8v_strb
	ldy  p8v_strb+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	bne  p8l_label_10_untilloop
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_63_afterif
label_asm_64_else
	lda  p8v_token
	cmp  #44
	bne  label_asm_66_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  conv.any2uword
	sta  p8v_strb
	stz  p8v_strb+1
	lda  cx16.r15L
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  cx16.r15H
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_65_afterif
label_asm_66_else
	lda  p8v_token
	cmp  #53
	bne  label_asm_68_else
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdstrvars.p8s_insert.p8v_name
	sty  p8b_jdstrvars.p8s_insert.p8v_name+1
	lda  #<prog8_interned_strings.string_7
	ldy  #>prog8_interned_strings.string_7
	sta  p8b_jdstrvars.p8s_insert.p8v_value
	sty  p8b_jdstrvars.p8s_insert.p8v_value+1
	jsr  p8b_jdstrvars.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_67_afterif
label_asm_68_else
	lda  p8v_token
	cmp  #52
	bne  label_asm_70_else
	lda  p8v_infuncheader
	beq  label_asm_72_else
	inc  p8v_paramcount
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_paramcount
	sta  p8b_jdlocal.p8s_insert.p8v_value
	stz  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_71_afterif
label_asm_72_else
	lda  p8b_main.p8v_fstack
	ora  p8b_main.p8v_fstack+1
	beq  label_asm_74_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdlocal.p8s_get_name
	sta  p8v_index
	lda  p8v_index
	beq  label_asm_76_else
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_index
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_75_afterif
label_asm_76_else
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdarrvars.p8s_insert.p8v_name
	sty  p8b_jdarrvars.p8s_insert.p8v_name+1
	lda  #<prog8_interned_strings.string_7
	ldy  #>prog8_interned_strings.string_7
	sta  p8b_jdarrvars.p8s_insert.p8v_value
	sty  p8b_jdarrvars.p8s_insert.p8v_value+1
	jsr  p8b_jdarrvars.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_75_afterif
	bra  label_asm_73_afterif
label_asm_74_else
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdarrvars.p8s_insert.p8v_name
	sty  p8b_jdarrvars.p8s_insert.p8v_name+1
	lda  #<prog8_interned_strings.string_7
	ldy  #>prog8_interned_strings.string_7
	sta  p8b_jdarrvars.p8s_insert.p8v_value
	sty  p8b_jdarrvars.p8s_insert.p8v_value+1
	jsr  p8b_jdarrvars.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_73_afterif
label_asm_71_afterif
	bra  label_asm_69_afterif
label_asm_70_else
	lda  p8v_token
	pha
	lda  #<p8v_auto_heap_value_5
	ldy  #>p8v_auto_heap_value_5
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_78_else
	lda  p8v_infuncheader
	beq  label_asm_80_else
	inc  p8v_paramcount
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_paramcount
	sta  p8b_jdlocal.p8s_insert.p8v_value
	stz  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_79_afterif
label_asm_80_else
	lda  p8b_main.p8v_fstack
	ora  p8b_main.p8v_fstack+1
	beq  label_asm_82_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdlocal.p8s_get_name
	sta  p8v_index
	lda  p8v_index
	beq  label_asm_84_else
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_index
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_83_afterif
label_asm_84_else
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdvars.p8s_insert.p8v_name
	sty  p8b_jdvars.p8s_insert.p8v_name+1
	stz  p8b_jdvars.p8s_insert.p8v_value
	stz  p8b_jdvars.p8s_insert.p8v_value+1
	jsr  p8b_jdvars.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_83_afterif
	bra  label_asm_81_afterif
label_asm_82_else
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdvars.p8s_insert.p8v_name
	sty  p8b_jdvars.p8s_insert.p8v_name+1
	stz  p8b_jdvars.p8s_insert.p8v_value
	stz  p8b_jdvars.p8s_insert.p8v_value+1
	jsr  p8b_jdvars.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_81_afterif
label_asm_79_afterif
	bra  label_asm_77_afterif
label_asm_78_else
	lda  p8v_token
	cmp  #71
	bne  label_asm_86_else
	lda  p8v_infuncheader
	beq  label_asm_88_else
	inc  p8v_paramcount
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  #$c7
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  #<$ff
	ldy  #>$ff
	sta  p8b_jdlocal.p8s_insert.p8v_value
	sty  p8b_jdlocal.p8s_insert.p8v_value+1
	
	jsr  p8b_jdlocal.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	bra  label_asm_87_afterif
label_asm_88_else
	lda  p8b_main.p8v_fstack
	ora  p8b_main.p8v_fstack+1
	beq  label_asm_90_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdfunc.p8s_get_FuncNoByName
	sta  p8v_index
	lda  p8v_index
	beq  label_asm_92_else
	lda  p8v_index
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_91_afterif
label_asm_92_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdlocal.p8s_get_indexbyname
	sta  p8v_index
	jsr  p8b_jdlocal.p8s_get_value
	sta  p8v_t1
	sty  p8v_t1+1
	lda  p8v_index
	beq  label_asm_93_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_index
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_93_afterif
	lda  #13
	jsr  txt.chrout
label_asm_91_afterif
	bra  label_asm_89_afterif
label_asm_90_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdfunc.p8s_get_FuncNoByName
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_89_afterif
label_asm_87_afterif
	bra  label_asm_85_afterif
label_asm_86_else
	lda  p8v_token
	cmp  #215
	bne  label_asm_95_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdfunc.p8s_get_FuncNoByName
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_94_afterif
label_asm_95_else
	lda  p8v_token
	cmp  #22
	bne  label_asm_96_afterif
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_labels.p8s_insert.p8v_name
	sty  p8b_labels.p8s_insert.p8v_name+1
	stz  p8b_labels.p8s_insert.p8v_value
	stz  p8b_labels.p8s_insert.p8v_value+1
	jsr  p8b_labels.p8s_insert
	sta  p8v_index
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_index
	sta  p8b_labels.p8s_set_value.p8v_index
	
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8b_labels.p8s_set_value.p8v_value
	sty  p8b_labels.p8s_set_value.p8v_value+1
	jsr  p8b_labels.p8s_set_value
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
label_asm_96_afterif
label_asm_94_afterif
label_asm_85_afterif
label_asm_77_afterif
label_asm_69_afterif
label_asm_67_afterif
label_asm_65_afterif
label_asm_63_afterif
	bra  label_asm_61_afterif
label_asm_62_else
	lda  p8v_token
	cmp  #25
	bne  label_asm_98_else
	inc  p8b_main.p8v_linenr
	bne  +
	inc  p8b_main.p8v_linenr+1
+
	lda  p8b_main.p8v_linenr
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_main.p8v_linenr+1
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	bra  label_asm_97_afterif
label_asm_98_else
	lda  p8v_token
	cmp  #46
	bne  label_asm_100_else
	lda  p8v_infuncheader
	beq  label_asm_102_else
	inc  p8v_paramcount
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #97
	bcc  label_asm_104_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sec
	sbc  #$20
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_103_afterif
label_asm_104_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
label_asm_103_afterif
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_paramcount
	sta  p8b_jdlocal.p8s_insert.p8v_value
	stz  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_101_afterif
label_asm_102_else
	lda  p8b_main.p8v_fstack
	ora  p8b_main.p8v_fstack+1
	beq  label_asm_106_else
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #97
	bcc  label_asm_108_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sec
	sbc  #$20
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_107_afterif
label_asm_108_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
label_asm_107_afterif
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_jdlocal.p8s_get_name
	sta  p8v_index
	lda  p8v_index
	beq  label_asm_110_else
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_token
	clc
	adc  #128
	sta  p8v_token
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_index
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_109_afterif
label_asm_110_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #97
	bcc  label_asm_112_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sec
	sbc  #$20
	sta  (p8b_main.p8v_pcode)
	bra  label_asm_111_afterif
label_asm_112_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  (p8b_main.p8v_pcode)
label_asm_111_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_109_afterif
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	bra  label_asm_105_afterif
label_asm_106_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #97
	bcc  label_asm_114_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sec
	sbc  #$20
	sta  (p8b_main.p8v_pcode)
	bra  label_asm_113_afterif
label_asm_114_else
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  (p8b_main.p8v_pcode)
label_asm_113_afterif
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_105_afterif
label_asm_101_afterif
	bra  label_asm_99_afterif
label_asm_100_else
	lda  p8v_token
	cmp  #1
	bne  label_asm_116_else
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8v_val
	sty  p8v_val+1
	lda  p8v_val
	bne  +
	dec  p8v_val+1
+                           dec  p8v_val
	jsr  p8b_main.p8s_parse
	sta  p8v_token
	cmp  #71
	bne  label_asm_117_afterif
	lda  #1
	sta  p8v_infuncheader
	stz  p8v_paramcount
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8b_jdfunc.p8s_insert.p8v_name
	sty  p8b_jdfunc.p8s_insert.p8v_name+1
	lda  p8v_val
	ldy  p8v_val+1
	sta  p8b_jdfunc.p8s_insert.p8v_value
	sty  p8b_jdfunc.p8s_insert.p8v_value+1
	jsr  p8b_jdfunc.p8s_insert
	sta  (p8b_main.p8v_pcode)
	ldy  #>prog8_interned_strings.string_8
	lda  #<prog8_interned_strings.string_8
	jsr  txt.print
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  txt.print
	lda  #$2c
	jsr  txt.chrout
	lda  #$20
	jsr  txt.chrout
	lda  (p8b_main.p8v_pcode)
	sec
	jsr  txt.print_ubhex
	lda  (p8b_main.p8v_pcode)
	sta  p8v_p_funcno
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8b_main.p8v_fstack
	sty  p8b_main.p8v_fstack+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8b_main.p8v_fstack1
	sty  p8b_main.p8v_fstack1+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
label_asm_117_afterif
	bra  label_asm_115_afterif
label_asm_116_else
	lda  p8v_token
	cmp  #38
	bne  label_asm_119_else
	lda  p8v_infuncheader
	beq  label_asm_120_afterif
	stz  p8v_infuncheader
	lda  p8b_main.p8v_fstack1
	ldy  p8b_main.p8v_fstack1+1
	sta  p8v_strb
	sty  p8v_strb+1
	ldy  #>prog8_interned_strings.string_10
	lda  #<prog8_interned_strings.string_10
	jsr  txt.print
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	sec
	jsr  txt.print_uwhex
	lda  p8b_main.p8v_pcode
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8b_main.p8v_pcode+1
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	stz  p8b_main.p8v_fstack1
	stz  p8b_main.p8v_fstack1+1
label_asm_120_afterif
	bra  label_asm_118_afterif
label_asm_119_else
	lda  p8v_token
	cmp  #43
	bne  label_asm_122_else
	lda  p8v_infuncheader
	beq  label_asm_123_afterif
	stz  p8v_infuncheader
	lda  p8b_main.p8v_fstack1
	ldy  p8b_main.p8v_fstack1+1
	sta  p8v_strb
	sty  p8v_strb+1
	ldy  #>prog8_interned_strings.string_11
	lda  #<prog8_interned_strings.string_11
	jsr  txt.print
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	sec
	jsr  txt.print_uwhex
	lda  p8b_main.p8v_pcode
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8b_main.p8v_pcode+1
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	stz  p8b_main.p8v_fstack1
	stz  p8b_main.p8v_fstack1+1
label_asm_123_afterif
	bra  label_asm_121_afterif
label_asm_122_else
	lda  p8v_token
	cmp  #6
	bne  label_asm_125_else
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8b_ifstack.p8s_push.p8v_elseaddress
	sty  p8b_ifstack.p8s_push.p8v_elseaddress+1
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	clc
	adc  #<2
	tax
	tya
	adc  #>2
	tay
	txa
	sta  p8b_ifstack.p8s_push.p8v_thenaddress
	sty  p8b_ifstack.p8s_push.p8v_thenaddress+1
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	clc
	adc  #<4
	tax
	tya
	adc  #>4
	tay
	txa
	sta  p8b_ifstack.p8s_push.p8v_endifaddress
	sty  p8b_ifstack.p8s_push.p8v_endifaddress+1
	jsr  p8b_ifstack.p8s_push
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  #0
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_124_afterif
label_asm_125_else
	lda  p8v_token
	cmp  #8
	bne  label_asm_127_else
	jsr  p8b_ifstack.p8s_pops
	sta  p8v_strb
	sty  p8v_strb+1
	lda  p8b_main.p8v_pcode
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8b_main.p8v_pcode+1
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_126_afterif
label_asm_127_else
	lda  p8v_token
	cmp  #7
	bne  label_asm_129_else
	jsr  p8b_ifstack.p8s_popm
	sta  p8v_strb
	sty  p8v_strb+1
	lda  p8b_main.p8v_pcode
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8b_main.p8v_pcode+1
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_128_afterif
label_asm_129_else
	lda  p8v_token
	cmp  #9
	bne  label_asm_131_else
	jsr  p8b_ifstack.p8s_pope
	sta  p8v_strb
	sty  p8v_strb+1
	lda  p8b_main.p8v_pcode
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8b_main.p8v_pcode+1
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_130_afterif
label_asm_131_else
	lda  p8v_token
	cmp  #2
	bne  label_asm_133_else
	lda  #2
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_main.p8v_fstack
	ldy  p8b_main.p8v_fstack+1
	sta  p8v_strb
	sty  p8v_strb+1
	ldy  #>prog8_interned_strings.string_12
	lda  #<prog8_interned_strings.string_12
	jsr  txt.print
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	sec
	jsr  txt.print_uwhex
	lda  #13
	jsr  txt.chrout
	lda  p8b_main.p8v_pcode
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_strb
	bne  +
	inc  p8v_strb+1
+
	lda  p8b_main.p8v_pcode+1
	ldy  p8v_strb
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_strb+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	stz  p8b_main.p8v_fstack
	stz  p8b_main.p8v_fstack+1
	bra  label_asm_132_afterif
label_asm_133_else
	lda  p8v_token
	cmp  #23
	bne  label_asm_134_afterif
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcs  p8l_label_151_celse
p8l_label_11_untilloop
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcc  p8l_label_11_untilloop
p8l_label_151_celse
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcc  p8l_label_153_celse
	lda  #<p8b_main.p8v_buffer
	ldy  #>p8b_main.p8v_buffer
	sta  p8v_lp
	sty  p8v_lp+1
p8l_label_12_untilloop
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8b_main.p8v_prgptr
	bne  +
	inc  p8b_main.p8v_prgptr+1
+
	lda  p8b_main.p8v_prgptr
	ldy  p8b_main.p8v_prgptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  string.isletter
	bcs  p8l_label_12_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_labels.p8s_get_jmpaddress
	sta  p8v_strb
	sty  p8v_strb+1
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_strb+1
	sta  (p8b_main.p8v_pcode)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
p8l_label_153_celse
label_asm_134_afterif
label_asm_132_afterif
label_asm_130_afterif
label_asm_128_afterif
label_asm_126_afterif
label_asm_124_afterif
label_asm_121_afterif
label_asm_118_afterif
label_asm_115_afterif
label_asm_99_afterif
label_asm_97_afterif
label_asm_61_afterif
	lda  p8v_token
	cmp  #127
	bne  p8l_label_14_untilloop
p8l_label_13_after
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
p8v_infuncheader	.byte  ?
p8v_lp	.word  ?
p8v_p_funcno	.byte  ?
p8v_paramcount	.byte  ?
p8v_pcodebase	.word  ?
p8v_rprgptr	.word  ?
p8v_strb	.word  ?
p8v_t1	.word  ?
p8v_token	.byte  ?
p8v_val	.word  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_5	.byte  $30, $44
	.pend

p8s_get_string	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_fname
	sty  p8v_fname+1
; statements
	sta  p8v_fptr
	sty  p8v_fptr+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
p8l_label_15_untilloop
	lda  (p8b_main.p8v_pcode)
	ldy  p8v_fptr
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_fptr+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8v_fptr
	bne  +
	inc  p8v_fptr+1
+
	lda  (p8b_main.p8v_pcode)
	bne  p8l_label_15_untilloop
	lda  #0
	ldy  p8v_fptr
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_fptr+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_fname	.word  ?
p8v_fptr	.word  ?
	.send BSS
	.pend

p8s_next	.proc
; statements
	stz  p8v_token
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_token
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_token	.byte  ?
	.send BSS
	.pend

p8s_tokenize_all	.proc
; statements
	stz  p8v_e
	stz  p8v_sbank
	stz  p8b_main.p8v_linenr
	stz  p8b_main.p8v_linenr+1
	; inlined routine follows: getrambank
        lda  $00
	; inlined routine end: getrambank
	sta  p8v_sbank
	lda  #2
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	lda  #<$a000
	ldy  #>$a000
	sta  p8b_main.p8s_tokenize.p8v_rprgptr
	sty  p8b_main.p8s_tokenize.p8v_rprgptr+1
	
	ldy  p8b_main.p8v_pend+1
	lda  p8b_main.p8v_pend
	clc
	adc  #<$a0
	tax
	tya
	adc  #>$a0
	tay
	txa
	sta  p8b_main.p8s_tokenize.p8v_pcodebase
	sty  p8b_main.p8s_tokenize.p8v_pcodebase+1
	jsr  p8b_main.p8s_tokenize
	sta  p8v_e
	lda  #$7f
	sta  (p8b_main.p8v_pcode)
	lda  #0
	ldy  #1
	sta  (p8b_main.p8v_pcode),y
	lda  p8v_sbank
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	lda  p8b_ifstack.p8v_isc
	beq  label_asm_135_afterif
	lda  #4
	jsr  p8b_error.p8s_set
	jsr  p8b_error.p8s_print
	jsr  p8b_error.p8s_clear
label_asm_135_afterif
	lda  p8b_main.p8v_fstack
	ora  p8b_main.p8v_fstack+1
	beq  label_asm_136_afterif
	lda  #5
	jsr  p8b_error.p8s_set
	jsr  p8b_error.p8s_print
	jsr  p8b_error.p8s_clear
label_asm_136_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_e	.byte  ?
p8v_sbank	.byte  ?
	.send BSS
	.pend

p8s_runl	.proc
; statements
	stz  p8v_token
	lda  p8b_main.p8v_pend
	ldy  p8b_main.p8v_pend+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
p8l_label_19_repeat
	lda  (p8b_main.p8v_pcode)
	sta  p8v_token
	cmp  #127
	beq  p8l_label_16_after
	lda  p8v_token
	jsr  p8b_main.p8s_statement
	lda  p8b_error.p8v_number
	beq  label_asm_137_afterif
	jsr  p8b_error.p8s_print
	bra  p8l_label_17_after
label_asm_137_afterif
	lda  (p8b_main.p8v_pcode)
	sta  p8v_token
	cmp  #127
	beq  p8l_label_18_after
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  p8l_label_19_repeat
p8l_label_18_after
p8l_label_17_after
p8l_label_16_after
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_token	.byte  ?
	.send BSS
	.pend

p8s_runp	.proc
; statements
	stz  p8v_token
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8v_ocode
	sty  p8v_ocode+1
	ldy  p8b_main.p8v_pend+1
	lda  p8b_main.p8v_pend
	clc
	adc  #<$a0
	tax
	tya
	adc  #>$a0
	tay
	txa
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	stz  p8b_ifstack.p8v_isc
	stz  p8b_funcstack.p8v_fsc
	stz  p8b_forstack.p8v_osc
	stz  p8b_varstack.p8v_vsc
	stz  p8b_callstack_b.p8v_cbsc
	stz  p8b_callstack_w.p8v_cwsc
p8l_label_21_repeat
	lda  (p8b_main.p8v_pcode)
	sta  p8v_token
	cmp  #127
	bne  label_asm_140_else
  lda  #1
	bra  label_asm_139_afterif
label_asm_140_else
  lda  #0
label_asm_139_afterif
	bne  label_asm_138_shortcut
	; inlined routine follows: STOP2
        jsr  cbm.STOP
	; inlined routine end: STOP2
	beq  +
	lda  #0
	beq  ++
+                   lda  #1
+
label_asm_138_shortcut
	bne  p8l_label_20_after
	lda  p8v_token
	jsr  p8b_main.p8s_statement
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  p8l_label_21_repeat
p8l_label_20_after
	ldy  #>prog8_interned_strings.string_1
	lda  #<prog8_interned_strings.string_1
	jsr  txt.print
	lda  #13
	jsr  txt.chrout
	lda  p8v_ocode
	ldy  p8v_ocode+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_ocode	.word  ?
p8v_token	.byte  ?
	.send BSS
	.pend

p8s_statement	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_token
; statements
	stz  p8v_status
	stz  p8v_line
	stz  p8v_line+1
	stz  p8v_l
	stz  p8v_m
	lda  p8b_main.p8v_trace
	cmp  #1
	bne  label_asm_141_afterif
	lda  #$28
	jsr  txt.chrout
	ldy  #0
	lda  p8v_token
	sec
	jsr  txt.print_uwhex
	lda  #$29
	jsr  txt.chrout
label_asm_141_afterif
	lda  p8v_token
	cmp  #117
	bne  label_asm_143_else
	jsr  p8b_runcmd.p8s_do_cls
	bra  label_asm_142_afterif
label_asm_143_else
	lda  p8v_token
	pha
	lda  #<p8v_auto_heap_value_6
	ldy  #>p8v_auto_heap_value_6
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #4
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_145_else
	lda  #0
	jsr  p8b_runlang.p8s_do_let
	bra  label_asm_144_afterif
label_asm_145_else
	lda  p8v_token
	pha
	lda  #<p8v_auto_heap_value_7
	ldy  #>p8v_auto_heap_value_7
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_147_else
	lda  #1
	jsr  p8b_runlang.p8s_do_let
	bra  label_asm_146_afterif
label_asm_147_else
	lda  p8v_token
	cmp  #53
	bne  label_asm_149_else
	lda  #2
	jsr  p8b_runlang.p8s_do_let
	bra  label_asm_148_afterif
label_asm_149_else
	lda  p8v_token
	cmp  #52
	bne  label_asm_151_else
	lda  #0
	jsr  p8b_runlang.p8s_do_array
	bra  label_asm_150_afterif
label_asm_151_else
	lda  p8v_token
	cmp  #180
	bne  label_asm_153_else
	lda  #1
	jsr  p8b_runlang.p8s_do_array
	bra  label_asm_152_afterif
label_asm_153_else
	lda  p8v_token
	cmp  #1
	bne  label_asm_155_else
	jsr  p8b_runlang.p8s_do_func
	bra  label_asm_154_afterif
label_asm_155_else
	lda  p8v_token
	cmp  #71
	bne  label_asm_157_else
	lda  #0
	jsr  p8b_runlang.p8s_do_callfunc
	bra  label_asm_156_afterif
label_asm_157_else
	lda  p8v_token
	cmp  #2
	bne  label_asm_159_else
	jsr  p8b_runlang.p8s_do_endfunc
	bra  label_asm_158_afterif
label_asm_159_else
	lda  p8v_token
	cmp  #6
	bne  label_asm_161_else
	jsr  p8b_runlang.p8s_do_if
	bra  label_asm_160_afterif
label_asm_161_else
	lda  p8v_token
	cmp  #7
	bne  label_asm_163_else
	jsr  p8b_runlang.p8s_do_then
	bra  label_asm_162_afterif
label_asm_163_else
	lda  p8v_token
	cmp  #25
	bne  label_asm_165_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_main.p8v_trace
	cmp  #1
	bne  label_asm_167_else
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_line
	sty  p8v_line+1
	lda  #$5b
	jsr  txt.chrout
	ldy  p8v_line+1
	lda  p8v_line
	sec
	jsr  txt.print_uwhex
	lda  #$5d
	jsr  txt.chrout
	bra  label_asm_166_afterif
label_asm_167_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_166_afterif
	bra  label_asm_164_afterif
label_asm_165_else
	lda  p8v_token
	cmp  #8
	bne  label_asm_169_else
	jsr  p8b_runlang.p8s_do_else
	bra  label_asm_168_afterif
label_asm_169_else
	lda  p8v_token
	cmp  #9
	bne  label_asm_171_else
	jsr  p8b_ifstack.p8s_pope
	bra  label_asm_170_afterif
label_asm_171_else
	lda  p8v_token
	cmp  #4
	bne  label_asm_173_else
	jsr  p8b_runlang.p8s_do_for
	bra  label_asm_172_afterif
label_asm_173_else
	lda  p8v_token
	cmp  #69
	bne  label_asm_175_else
	jsr  p8b_runlang.p8s_do_next
	bra  label_asm_174_afterif
label_asm_175_else
	lda  p8v_token
	cmp  #24
	bne  label_asm_177_else
	jsr  p8b_runcmd.p8s_do_print
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	bra  label_asm_176_afterif
label_asm_177_else
	lda  p8v_token
	cmp  #112
	bne  label_asm_179_else
	jsr  p8b_rundos.p8s_do_list
	bra  label_asm_178_afterif
label_asm_179_else
	lda  p8v_token
	cmp  #23
	bne  label_asm_181_else
	jsr  p8b_runlang.p8s_do_goto
	bra  label_asm_180_afterif
label_asm_181_else
	lda  p8v_token
	cmp  #22
	bne  label_asm_183_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_182_afterif
label_asm_183_else
	lda  p8v_token
	cmp  #73
	bne  label_asm_185_else
	jsr  p8b_runcmd.p8s_do_poke
	bra  label_asm_184_afterif
label_asm_185_else
	lda  p8v_token
	cmp  #75
	bne  label_asm_187_else
	jsr  p8b_runcmd.p8s_do_vpoke
	bra  label_asm_186_afterif
label_asm_187_else
	lda  p8v_token
	cmp  #76
	bne  label_asm_189_else
	jsr  p8b_runcmd.p8s_do_flupp
	bra  label_asm_188_afterif
label_asm_189_else
	lda  p8v_token
	cmp  #190
	bne  label_asm_191_else
	jsr  p8b_runcmd.p8s_do_setchr
	bra  label_asm_190_afterif
label_asm_191_else
	lda  p8v_token
	cmp  #201
	bne  label_asm_193_else
	jsr  p8b_runcmd.p8s_do_setclr
	bra  label_asm_192_afterif
label_asm_193_else
	lda  p8v_token
	cmp  #188
	bne  label_asm_195_else
	jsr  p8b_runcmd.p8s_do_color
	bra  label_asm_194_afterif
label_asm_195_else
	lda  p8v_token
	cmp  #189
	bne  label_asm_197_else
	jsr  p8b_runcmd.p8s_do_locate
	bra  label_asm_196_afterif
label_asm_197_else
	lda  p8v_token
	cmp  #203
	bne  label_asm_199_else
	jsr  p8b_runcmd.p8s_do_graph
	bra  label_asm_198_afterif
label_asm_199_else
	lda  p8v_token
	cmp  #204
	bne  label_asm_201_else
	jsr  p8b_runcmd.p8s_do_line
	bra  label_asm_200_afterif
label_asm_201_else
	lda  p8v_token
	cmp  #205
	bne  label_asm_203_else
	jsr  p8b_runcmd.p8s_do_rect
	bra  label_asm_202_afterif
label_asm_203_else
	lda  p8v_token
	cmp  #206
	bne  label_asm_205_else
	jsr  p8b_runcmd.p8s_do_wait
	bra  label_asm_204_afterif
label_asm_205_else
	lda  p8v_token
	cmp  #118
	bne  label_asm_207_else
	lda  #1
	sta  p8b_main.p8v_trace
	bra  label_asm_206_afterif
label_asm_207_else
	lda  p8v_token
	cmp  #119
	bne  label_asm_209_else
	stz  p8b_main.p8v_trace
	bra  label_asm_208_afterif
label_asm_209_else
	lda  p8v_token
	cmp  #207
	bne  label_asm_211_else
	jsr  p8b_runcmd.p8s_do_plot
	bra  label_asm_210_afterif
label_asm_211_else
	lda  p8v_token
	cmp  #116
	bne  label_asm_213_else
	jsr  p8b_rundos.p8s_do_load
	sta  p8v_status
	lda  p8v_status
	bne  label_asm_214_afterif
	jsr  p8b_main.p8s_tokenize_all
	lda  p8b_main.p8v_pcode
	sta  P8ZP_SCRATCH_W1
	lda  p8b_main.p8v_pcode+1
	sta  P8ZP_SCRATCH_W1+1
	ldy  #>-$6101
	lda  #<-$6101
	sec
	sbc  P8ZP_SCRATCH_W1
	tax
	tya
	sbc  P8ZP_SCRATCH_W1+1
	tay
	txa
	sta  p8v_mem
	sty  p8v_mem+1
	ldy  #>prog8_interned_strings.string_4
	lda  #<prog8_interned_strings.string_4
	jsr  txt.print
	ldy  p8v_mem+1
	lda  p8v_mem
	jsr  txt.print_uw
	lda  #13
	jsr  txt.chrout
label_asm_214_afterif
	bra  label_asm_212_afterif
label_asm_213_else
	lda  p8v_token
	cmp  #114
	bne  label_asm_216_else
	jsr  p8b_rundos.p8s_do_edit
	bra  label_asm_215_afterif
label_asm_216_else
	lda  p8v_token
	cmp  #115
	bne  label_asm_218_else
	jsr  p8b_rundos.p8s_do_dir
	bra  label_asm_217_afterif
label_asm_218_else
	lda  p8v_token
	cmp  #113
	bne  label_asm_219_afterif
	jsr  p8b_main.p8s_runp
label_asm_219_afterif
label_asm_217_afterif
label_asm_215_afterif
label_asm_212_afterif
label_asm_210_afterif
label_asm_208_afterif
label_asm_206_afterif
label_asm_204_afterif
label_asm_202_afterif
label_asm_200_afterif
label_asm_198_afterif
label_asm_196_afterif
label_asm_194_afterif
label_asm_192_afterif
label_asm_190_afterif
label_asm_188_afterif
label_asm_186_afterif
label_asm_184_afterif
label_asm_182_afterif
label_asm_180_afterif
label_asm_178_afterif
label_asm_176_afterif
label_asm_174_afterif
label_asm_172_afterif
label_asm_170_afterif
label_asm_168_afterif
label_asm_164_afterif
label_asm_162_afterif
label_asm_160_afterif
label_asm_158_afterif
label_asm_156_afterif
label_asm_154_afterif
label_asm_152_afterif
label_asm_150_afterif
label_asm_148_afterif
label_asm_146_afterif
label_asm_144_afterif
label_asm_142_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_l	.byte  ?
p8v_line	.word  ?
p8v_m	.byte  ?
p8v_mem	.word  ?
p8v_status	.byte  ?
p8v_token	.byte  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_6	.byte  $30, $44, $b0, $c4
p8v_auto_heap_value_7	.byte  $2e, $ae
	.pend

p8s_singlechar	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_ptr
; statements
	cmp  #10
	bne  label_asm_220_afterif
	lda  #$19
	rts
label_asm_220_afterif
	lda  p8v_ptr
	cmp  #44
	bne  label_asm_221_afterif
	lda  #$1a
	rts
label_asm_221_afterif
	lda  p8v_ptr
	cmp  #59
	bne  label_asm_222_afterif
	lda  #$1b
	rts
label_asm_222_afterif
	lda  p8v_ptr
	cmp  #43
	bne  label_asm_223_afterif
	lda  #$1c
	rts
label_asm_223_afterif
	lda  p8v_ptr
	cmp  #45
	bne  label_asm_224_afterif
	lda  #$1d
	rts
label_asm_224_afterif
	lda  p8v_ptr
	cmp  #124
	bne  label_asm_225_afterif
	lda  #$1e
	rts
label_asm_225_afterif
	lda  p8v_ptr
	cmp  #42
	bne  label_asm_226_afterif
	lda  #$1f
	rts
label_asm_226_afterif
	lda  p8v_ptr
	cmp  #47
	bne  label_asm_227_afterif
	lda  #$20
	rts
label_asm_227_afterif
	lda  p8v_ptr
	cmp  #37
	bne  label_asm_228_afterif
	lda  #$21
	rts
label_asm_228_afterif
	lda  p8v_ptr
	cmp  #40
	bne  label_asm_229_afterif
	lda  #$22
	rts
label_asm_229_afterif
	lda  p8v_ptr
	cmp  #91
	bne  label_asm_230_afterif
	lda  #$23
	rts
label_asm_230_afterif
	lda  p8v_ptr
	cmp  #93
	bne  label_asm_231_afterif
	lda  #$24
	rts
label_asm_231_afterif
	lda  p8v_ptr
	cmp  #35
	bne  label_asm_232_afterif
	lda  #$25
	rts
label_asm_232_afterif
	lda  p8v_ptr
	cmp  #41
	bne  label_asm_233_afterif
	lda  #$26
	rts
label_asm_233_afterif
	lda  p8v_ptr
	cmp  #60
	bne  label_asm_234_afterif
	lda  #$27
	rts
label_asm_234_afterif
	lda  p8v_ptr
	cmp  #62
	bne  label_asm_235_afterif
	lda  #$28
	rts
label_asm_235_afterif
	lda  p8v_ptr
	cmp  #61
	bne  label_asm_236_afterif
	lda  #$29
	rts
label_asm_236_afterif
	lda  p8v_ptr
	cmp  #36
	bne  label_asm_237_afterif
	lda  #$2a
	rts
label_asm_237_afterif
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_ptr	.byte  ?
	.send BSS
	.pend
prog8_init_vars	.block
	stz  p8b_main.p8v_pcode
	stz  p8b_main.p8v_pcode+1
	lda  #5
	sta  p8b_main.p8v_fgcolor
	rts
	.bend
	.pend

; ---- block: 'p8b_consts' ----
p8b_consts	.proc

; non-zeropage variables
p8v_DELIMITERCHAR	; ISO:" =,;#()]*/-+%&><"
	.byte  $20, $3d, $2c, $3b, $23, $28, $29, $5d, $2a, $2f, $2d, $2b, $25, $26, $3e, $3c
	.byte  $00

	.pend

; ---- block: 'p8b_statements' ----
p8b_statements	.proc

; non-zeropage variables
p8v_statements_table
	.word  prog8_interned_strings.string_17, $0070, prog8_interned_strings.string_18, $0071, prog8_interned_strings.string_19, $0072, prog8_interned_strings.string_20, $0073, prog8_interned_strings.string_21, $0074, prog8_interned_strings.string_22, $0075, prog8_interned_strings.string_23, $0001, prog8_interned_strings.string_24, $0002
	.word  prog8_interned_strings.string_25, $0003, prog8_interned_strings.string_26, $0004, prog8_interned_strings.string_27, $0005, prog8_interned_strings.string_28, $0006, prog8_interned_strings.string_29, $0007, prog8_interned_strings.string_30, $0008, prog8_interned_strings.string_31, $0009, prog8_interned_strings.string_32, $000a
	.word  prog8_interned_strings.string_33, $000b, prog8_interned_strings.string_34, $000c, prog8_interned_strings.string_35, $000d, prog8_interned_strings.string_36, $000e, prog8_interned_strings.string_37, $000f, prog8_interned_strings.string_38, $0010, prog8_interned_strings.string_39, $0011, prog8_interned_strings.string_40, $0012
	.word  prog8_interned_strings.string_41, $0013, prog8_interned_strings.string_42, $0014, prog8_interned_strings.string_43, $0015, prog8_interned_strings.string_44, $0017, prog8_interned_strings.string_45, $0018, prog8_interned_strings.string_46, $002b, prog8_interned_strings.string_47, $0043, prog8_interned_strings.string_48, $0045
	.word  prog8_interned_strings.string_49, $0046, prog8_interned_strings.string_50, $0048, prog8_interned_strings.string_51, $0049, prog8_interned_strings.string_52, $004a, prog8_interned_strings.string_53, $004b, prog8_interned_strings.string_54, $004c, prog8_interned_strings.string_55, $004d, prog8_interned_strings.string_56, $00ba
	.word  prog8_interned_strings.string_57, $00bb, prog8_interned_strings.string_58, $00bc, prog8_interned_strings.string_59, $00bd, prog8_interned_strings.string_60, $00be, prog8_interned_strings.string_61, $00c9, prog8_interned_strings.string_62, $00bf, prog8_interned_strings.string_63, $00c0, prog8_interned_strings.string_64, $00c1
	.word  prog8_interned_strings.string_65, $00c2, prog8_interned_strings.string_66, $00c3, prog8_interned_strings.string_67, $00ca, prog8_interned_strings.string_68, $00c5, prog8_interned_strings.string_69, $00c6, prog8_interned_strings.string_70, $00c8, prog8_interned_strings.string_67, $00ca, prog8_interned_strings.string_71, $00cb
	.word  prog8_interned_strings.string_72, $00cc, prog8_interned_strings.string_73, $00cd, prog8_interned_strings.string_74, $00ce, prog8_interned_strings.string_75, $00cf, prog8_interned_strings.string_76, $00d0, prog8_interned_strings.string_77, $00d1, prog8_interned_strings.string_78, $0076, prog8_interned_strings.string_79, $0077


p8s_get	.proc
p8v_statement 	= 52 	; zp UWORD
p8v_i 	= 54 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  p8v_statement
	sty  p8v_statement+1
; statements
	lda  #0
	sta  p8v_i
label_asm_238_for_loop
	lda  p8v_statement
	sta  cx16.r0
	lda  p8v_statement+1
	sta  cx16.r0+1
	
	lda  p8v_i
	asl  a
	tay
	lda  p8b_statements.p8v_statements_table,y
	ldx  p8b_statements.p8v_statements_table+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	jsr  string.compare
	cmp  #0
	bne  label_asm_240_afterif
	lda  p8v_i
	clc
	adc  #1
	asl  a
	tay
	lda  p8b_statements.p8v_statements_table,y
	ldx  p8b_statements.p8v_statements_table+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_240_afterif
	inc  p8v_i
	inc  p8v_i
	lda  p8v_i
	cmp  #128
	bne  label_asm_238_for_loop
label_asm_239_for_end
	lda  #0
	tay
	rts
; variables
	.section BSS
	.send BSS

	.pend
	.pend

; ---- block: 'prog8_interned_strings' ----
prog8_interned_strings	.proc

; non-zeropage variables
string_1	; ISO:"Ready"
	.byte  $52, $65, $61, $64, $79, $00
string_10	; ISO:", add1: "
	.byte  $2c, $20, $61, $64, $64, $31, $3a, $20, $00
string_100	; ISO:", mt: "
	.byte  $2c, $20, $6d, $74, $3a, $20, $00
string_101	; ISO:", i: "
	.byte  $2c, $20, $69, $3a, $20, $00
string_102	; ISO:" in line "
	.byte  $20, $69, $6e, $20, $6c, $69, $6e, $65, $20, $00
string_103	; ISO:"none"
	.byte  $6e, $6f, $6e, $65, $00
string_104	; ISO:"Syntax Error"
	.byte  $53, $79, $6e, $74, $61, $78, $20, $45, $72, $72, $6f, $72, $00
string_105	; ISO:"Command not expected"
	.byte  $43, $6f, $6d, $6d, $61, $6e, $64, $20, $6e, $6f, $74, $20, $65, $78, $70, $65
	.byte  $63, $74, $65, $64, $00
string_106	; ISO:"Failed to load file."
	.byte  $46, $61, $69, $6c, $65, $64, $20, $74, $6f, $20, $6c, $6f, $61, $64, $20, $66
	.byte  $69, $6c, $65, $2e, $00
string_107	; ISO:"If with no endif found"
	.byte  $49, $66, $20, $77, $69, $74, $68, $20, $6e, $6f, $20, $65, $6e, $64, $69, $66
	.byte  $20, $66, $6f, $75, $6e, $64, $00
string_108	; ISO:"open function found"
	.byte  $6f, $70, $65, $6e, $20, $66, $75, $6e, $63, $74, $69, $6f, $6e, $20, $66, $6f
	.byte  $75, $6e, $64, $00
string_109	; ISO:"next not matching for"
	.byte  $6e, $65, $78, $74, $20, $6e, $6f, $74, $20, $6d, $61, $74, $63, $68, $69, $6e
	.byte  $67, $20, $66, $6f, $72, $00
string_11	; ISO:", ret: "
	.byte  $2c, $20, $72, $65, $74, $3a, $20, $00
string_110	; ISO:"loaded to: "
	.byte  $6c, $6f, $61, $64, $65, $64, $20, $74, $6f, $3a, $20, $00
string_111	; ISO:" bank "
	.byte  $20, $62, $61, $6e, $6b, $20, $00
string_112	; ISO:"*"
	.byte  $2a, $00
string_113	; ISO:" Blocks  Filename\r"
	.byte  $20, $42, $6c, $6f, $63, $6b, $73, $20, $20, $46, $69, $6c, $65, $6e, $61, $6d
	.byte  $65, $0d, $00
string_114	; ISO:"[dir]"
	.byte  $5b, $64, $69, $72, $5d, $00
string_115	; ISO:"Break\r"
	.byte  $42, $72, $65, $61, $6b, $0d, $00
string_116	; ISO:"No files\r"
	.byte  $4e, $6f, $20, $66, $69, $6c, $65, $73, $0d, $00
string_117	; ISO:"No x16edit found."
	.byte  $4e, $6f, $20, $78, $31, $36, $65, $64, $69, $74, $20, $66, $6f, $75, $6e, $64
	.byte  $2e, $00
string_12	; ISO:", end: "
	.byte  $2c, $20, $65, $6e, $64, $3a, $20, $00
string_17	; ISO:"list"
	.byte  $6c, $69, $73, $74, $00
string_18	; ISO:"run"
	.byte  $72, $75, $6e, $00
string_19	; ISO:"edit"
	.byte  $65, $64, $69, $74, $00
string_2	; ISO:"Basic end:   "
	.byte  $42, $61, $73, $69, $63, $20, $65, $6e, $64, $3a, $20, $20, $20, $00
string_20	; ISO:"dir"
	.byte  $64, $69, $72, $00
string_21	; ISO:"load"
	.byte  $6c, $6f, $61, $64, $00
string_22	; ISO:"cls"
	.byte  $63, $6c, $73, $00
string_23	; ISO:"func"
	.byte  $66, $75, $6e, $63, $00
string_24	; ISO:"endfunc"
	.byte  $65, $6e, $64, $66, $75, $6e, $63, $00
string_25	; ISO:"local"
	.byte  $6c, $6f, $63, $61, $6c, $00
string_26	; ISO:"for"
	.byte  $66, $6f, $72, $00
string_27	; ISO:"break"
	.byte  $62, $72, $65, $61, $6b, $00
string_28	; ISO:"if"
	.byte  $69, $66, $00
string_29	; ISO:"then"
	.byte  $74, $68, $65, $6e, $00
string_3	; ISO:"Prog start:  "
	.byte  $50, $72, $6f, $67, $20, $73, $74, $61, $72, $74, $3a, $20, $20, $00
string_30	; ISO:"else"
	.byte  $65, $6c, $73, $65, $00
string_31	; ISO:"endif"
	.byte  $65, $6e, $64, $69, $66, $00
string_32	; ISO:"and"
	.byte  $61, $6e, $64, $00
string_33	; ISO:"or"
	.byte  $6f, $72, $00
string_34	; ISO:"not"
	.byte  $6e, $6f, $74, $00
string_35	; ISO:"mod"
	.byte  $6d, $6f, $64, $00
string_36	; ISO:"true"
	.byte  $74, $72, $75, $65, $00
string_37	; ISO:"false"
	.byte  $66, $61, $6c, $73, $65, $00
string_38	; ISO:"do"
	.byte  $64, $6f, $00
string_39	; ISO:"while"
	.byte  $77, $68, $69, $6c, $65, $00
string_4	; ISO:"Free memory: "
	.byte  $46, $72, $65, $65, $20, $6d, $65, $6d, $6f, $72, $79, $3a, $20, $00
string_40	; ISO:"repeat"
	.byte  $72, $65, $70, $65, $61, $74, $00
string_41	; ISO:"until"
	.byte  $75, $6e, $74, $69, $6c, $00
string_42	; ISO:"dim"
	.byte  $64, $69, $6d, $00
string_43	; ISO:"as"
	.byte  $61, $73, $00
string_44	; ISO:"goto"
	.byte  $67, $6f, $74, $6f, $00
string_45	; ISO:"print"
	.byte  $70, $72, $69, $6e, $74, $00
string_46	; ISO:"return"
	.byte  $72, $65, $74, $75, $72, $6e, $00
string_47	; ISO:"to"
	.byte  $74, $6f, $00
string_48	; ISO:"next"
	.byte  $6e, $65, $78, $74, $00
string_49	; ISO:"step"
	.byte  $73, $74, $65, $70, $00
string_5	; ISO:"NeReLa Basic v 0.6"
	.byte  $4e, $65, $52, $65, $4c, $61, $20, $42, $61, $73, $69, $63, $20, $76, $20, $30
	.byte  $2e, $36, $00
string_50	; ISO:"peek"
	.byte  $70, $65, $65, $6b, $00
string_51	; ISO:"poke"
	.byte  $70, $6f, $6b, $65, $00
string_52	; ISO:"vpeek"
	.byte  $76, $70, $65, $65, $6b, $00
string_53	; ISO:"vpoke"
	.byte  $76, $70, $6f, $6b, $65, $00
string_54	; ISO:"flupp"
	.byte  $66, $6c, $75, $70, $70, $00
string_55	; ISO:"input"
	.byte  $69, $6e, $70, $75, $74, $00
string_56	; ISO:"get"
	.byte  $67, $65, $74, $00
string_57	; ISO:"len"
	.byte  $6c, $65, $6e, $00
string_58	; ISO:"color"
	.byte  $63, $6f, $6c, $6f, $72, $00
string_59	; ISO:"locate"
	.byte  $6c, $6f, $63, $61, $74, $65, $00
string_6	; ISO:"(c) 2024"
	.byte  $28, $63, $29, $20, $32, $30, $32, $34, $00
string_60	; ISO:"setchr"
	.byte  $73, $65, $74, $63, $68, $72, $00
string_61	; ISO:"setclr"
	.byte  $73, $65, $74, $63, $6c, $72, $00
string_62	; ISO:"jiffi"
	.byte  $6a, $69, $66, $66, $69, $00
string_63	; ISO:"left"
	.byte  $6c, $65, $66, $74, $00
string_64	; ISO:"right"
	.byte  $72, $69, $67, $68, $74, $00
string_65	; ISO:"mid"
	.byte  $6d, $69, $64, $00
string_66	; ISO:"trim"
	.byte  $74, $72, $69, $6d, $00
string_67	; ISO:"chr"
	.byte  $63, $68, $72, $00
string_68	; ISO:"asc"
	.byte  $61, $73, $63, $00
string_69	; ISO:"rnd"
	.byte  $72, $6e, $64, $00
string_7	; ISO:""
	.byte  $00
string_70	; ISO:"joy"
	.byte  $6a, $6f, $79, $00
string_71	; ISO:"graph"
	.byte  $67, $72, $61, $70, $68, $00
string_72	; ISO:"line"
	.byte  $6c, $69, $6e, $65, $00
string_73	; ISO:"rect"
	.byte  $72, $65, $63, $74, $00
string_74	; ISO:"circle"
	.byte  $63, $69, $72, $63, $6c, $65, $00
string_75	; ISO:"plot"
	.byte  $70, $6c, $6f, $74, $00
string_76	; ISO:"getxy"
	.byte  $67, $65, $74, $78, $79, $00
string_77	; ISO:"wait"
	.byte  $77, $61, $69, $74, $00
string_78	; ISO:"tron"
	.byte  $74, $72, $6f, $6e, $00
string_79	; ISO:"troff"
	.byte  $74, $72, $6f, $66, $66, $00
string_8	; ISO:"func: "
	.byte  $66, $75, $6e, $63, $3a, $20, $00
string_82	; PETSCII:"$"
	.byte  $24, $00
string_84	; PETSCII:"dir"
	.byte  $44, $49, $52, $00
string_87	; ISO:"command FLUPP testcode here."
	.byte  $63, $6f, $6d, $6d, $61, $6e, $64, $20, $46, $4c, $55, $50, $50, $20, $74, $65
	.byte  $73, $74, $63, $6f, $64, $65, $20, $68, $65, $72, $65, $2e, $00
string_90	; ISO:"if: "
	.byte  $69, $66, $3a, $20, $00
string_91	; ISO:"op: "
	.byte  $6f, $70, $3a, $20, $00
string_92	; ISO:"if "
	.byte  $69, $66, $20, $00
string_93	; ISO:"else "
	.byte  $65, $6c, $73, $65, $20, $00
string_94	; ISO:"start mt: "
	.byte  $73, $74, $61, $72, $74, $20, $6d, $74, $3a, $20, $00
string_95	; ISO:",i: "
	.byte  $2c, $69, $3a, $20, $00
string_96	; ISO:"call: , "
	.byte  $63, $61, $6c, $6c, $3a, $20, $2c, $20, $00
string_97	; ISO:"call2 : , "
	.byte  $63, $61, $6c, $6c, $32, $20, $3a, $20, $2c, $20, $00
string_98	; ISO:"call e: , "
	.byte  $63, $61, $6c, $6c, $20, $65, $3a, $20, $2c, $20, $00
string_99	; ISO:"val: "
	.byte  $76, $61, $6c, $3a, $20, $00

	.pend

; ---- block: 'cbm' ----
cbm	.proc

	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	PLOT = $fff0
	IOBASE = $fff3









































RDTIM_safe	.proc
        php
        sei
        jsr  cbm.RDTIM
        plp
        rts
	.pend

RDTIM16	.proc
        jsr  RDTIM_safe
        pha
        txa
        tay
        pla
        rts
	.pend

kbdbuf_clear	.proc
-       jsr  GETIN
        cmp  #0
        bne  -
        rts
	.pend
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	r0 = 2
	r0s = 2
	r0L = 2
	r0sL = 2
	r0H = 3
	r0sH = 3
	r1 = 4
	r1s = 4
	r1L = 4
	r1sL = 4
	r1H = 5
	r1sH = 5
	r2 = 6
	r2s = 6
	r2L = 6
	r2sL = 6
	r2H = 7
	r2sH = 7
	r3 = 8
	r3s = 8
	r3L = 8
	r3sL = 8
	r3H = 9
	r3sH = 9
	r4 = 10
	r4s = 10
	r4L = 10
	r4sL = 10
	r4H = 11
	r4sH = 11
	r5 = 12
	r5s = 12
	r5L = 12
	r5sL = 12
	r5H = 13
	r5sH = 13
	r6 = 14
	r6s = 14
	r6L = 14
	r6sL = 14
	r6H = 15
	r6sH = 15
	r7 = $10
	r7s = $10
	r7L = $10
	r7sL = $10
	r7H = $11
	r7sH = $11
	r8 = $12
	r8s = $12
	r8L = $12
	r8sL = $12
	r8H = $13
	r8sH = $13
	r9 = $14
	r9s = $14
	r9L = $14
	r9sL = $14
	r9H = $15
	r9sH = $15
	r10 = $16
	r10s = $16
	r10L = $16
	r10sL = $16
	r10H = $17
	r10sH = $17
	r11 = $18
	r11s = $18
	r11L = $18
	r11sL = $18
	r11H = $19
	r11sH = $19
	r12 = $1a
	r12s = $1a
	r12L = $1a
	r12sL = $1a
	r12H = $1b
	r12sH = $1b
	r13 = $1c
	r13s = $1c
	r13L = $1c
	r13sL = $1c
	r13H = $1d
	r13sH = $1d
	r14 = $1e
	r14s = $1e
	r14L = $1e
	r14sL = $1e
	r14H = $1f
	r14sH = $1f
	r15 = $20
	r15s = $20
	r15L = $20
	r15sL = $20
	r15H = $21
	r15sH = $21
	IERROR = $0300
	IMAIN = $0302
	ICRNCH = $0304
	IQPLOP = $0306
	IGONE = $0308
	IEVAL = $030a
	SAREG = $030c
	SXREG = $030d
	SYREG = $030e
	SPREG = $030f
	USRADD = $0311
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	IOPEN = $031a
	ICLOSE = $031c
	ICHKIN = $031e
	ICKOUT = $0320
	ICLRCH = $0322
	IBASIN = $0324
	IBSOUT = $0326
	ISTOP = $0328
	IGETIN = $032a
	ICLALL = $032c
	KEYHDL = $032e
	ILOAD = $0330
	ISAVE = $0332
	via1prb = $9f00
	via1pra = $9f01
	via1ddrb = $9f02
	via1ddra = $9f03
	via1t1l = $9f04
	via1t1h = $9f05
	via1t1ll = $9f06
	via1t1lh = $9f07
	via1t2l = $9f08
	via1t2h = $9f09
	via1sr = $9f0a
	via1acr = $9f0b
	via1pcr = $9f0c
	via1ifr = $9f0d
	via1ier = $9f0e
	via1ora = $9f0f
	via2prb = $9f10
	via2pra = $9f11
	via2ddrb = $9f12
	via2ddra = $9f13
	via2t1l = $9f14
	via2t1h = $9f15
	via2t1ll = $9f16
	via2t1lh = $9f17
	via2t2l = $9f18
	via2t2h = $9f19
	via2sr = $9f1a
	via2acr = $9f1b
	via2pcr = $9f1c
	via2ifr = $9f1d
	via2ier = $9f1e
	via2ora = $9f1f
	VERA_ADDR_L = $9f20
	VERA_ADDR = $9f20
	VERA_ADDR_M = $9f21
	VERA_ADDR_H = $9f22
	VERA_DATA0 = $9f23
	VERA_DATA1 = $9f24
	VERA_CTRL = $9f25
	VERA_IEN = $9f26
	VERA_ISR = $9f27
	VERA_IRQLINE_L = $9f28
	VERA_SCANLINE_L = $9f28
	VERA_DC_VIDEO = $9f29
	VERA_DC_HSTART = $9f29
	VERA_DC_VER0 = $9f29
	VERA_FX_CTRL = $9f29
	VERA_FX_X_INCR_L = $9f29
	VERA_FX_X_INCR = $9f29
	VERA_FX_X_POS_L = $9f29
	VERA_FX_X_POS = $9f29
	VERA_FX_X_POS_S = $9f29
	VERA_FX_CACHE_L = $9f29
	VERA_FX_ACCUM_RESET = $9f29
	VERA_DC_HSCALE = $9f2a
	VERA_DC_HSTOP = $9f2a
	VERA_DC_VER1 = $9f2a
	VERA_FX_TILEBASE = $9f2a
	VERA_FX_X_INCR_H = $9f2a
	VERA_FX_X_POS_H = $9f2a
	VERA_FX_Y_POS_S = $9f2a
	VERA_FX_CACHE_M = $9f2a
	VERA_FX_ACCUM = $9f2a
	VERA_DC_VSCALE = $9f2b
	VERA_DC_VSTART = $9f2b
	VERA_DC_VER2 = $9f2b
	VERA_FX_MAPBASE = $9f2b
	VERA_FX_Y_INCR_L = $9f2b
	VERA_FX_Y_INCR = $9f2b
	VERA_FX_Y_POS_L = $9f2b
	VERA_FX_Y_POS = $9f2b
	VERA_FX_POLY_FILL_L = $9f2b
	VERA_FX_POLY_FILL = $9f2b
	VERA_FX_CACHE_H = $9f2b
	VERA_DC_BORDER = $9f2c
	VERA_DC_VSTOP = $9f2c
	VERA_DC_VER3 = $9f2c
	VERA_FX_MULT = $9f2c
	VERA_FX_Y_INCR_H = $9f2c
	VERA_FX_Y_POS_H = $9f2c
	VERA_FX_POLY_FILL_H = $9f2c
	VERA_FX_CACHE_U = $9f2c
	VERA_L0_CONFIG = $9f2d
	VERA_L0_MAPBASE = $9f2e
	VERA_L0_TILEBASE = $9f2f
	VERA_L0_HSCROLL_L = $9f30
	VERA_L0_HSCROLL = $9f30
	VERA_L0_HSCROLL_H = $9f31
	VERA_L0_VSCROLL_L = $9f32
	VERA_L0_VSCROLL = $9f32
	VERA_L0_VSCROLL_H = $9f33
	VERA_L1_CONFIG = $9f34
	VERA_L1_MAPBASE = $9f35
	VERA_L1_TILEBASE = $9f36
	VERA_L1_HSCROLL_L = $9f37
	VERA_L1_HSCROLL = $9f37
	VERA_L1_HSCROLL_H = $9f38
	VERA_L1_VSCROLL_L = $9f39
	VERA_L1_VSCROLL = $9f39
	VERA_L1_VSCROLL_H = $9f3a
	VERA_AUDIO_CTRL = $9f3b
	VERA_AUDIO_RATE = $9f3c
	VERA_AUDIO_DATA = $9f3d
	VERA_SPI_DATA = $9f3e
	VERA_SPI_CTRL = $9f3f
	YM_ADDRESS = $9f40
	YM_DATA = $9f41
	edkeyvec = $ac03
	edkeybk = $ac05
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe
	EXTAPI16_stack_enter_kernal_stack = 3
	EXTAPI16_stack_leave_kernal_stack = 4
	EXTAPI16_stack_pop = 2
	EXTAPI16_stack_push = 1
	EXTAPI16_test = 0
	EXTAPI_clear_status = 1
	EXTAPI_cursor_blink = 10
	EXTAPI_getlfs = 2
	EXTAPI_iso_cursor_char = 5
	EXTAPI_joystick_ps2_keycodes = 4
	EXTAPI_led_update = 11
	EXTAPI_mouse_set_position = 12
	EXTAPI_mouse_sprite_offset = 3
	EXTAPI_pfkey = 7
	EXTAPI_ps2data_fetch = 8
	EXTAPI_ps2data_raw = 9
	EXTAPI_ps2kbd_typematic = 6
	VERA_BASE = $9f20
	VIA1_BASE = $9f00
	VIA2_BASE = $9f10
	extdev = $9f60

	CLOSE_ALL = $ff4a
	LKUPLA = $ff59
	LKUPSA = $ff5c
	screen_mode = $ff5f
	screen_set_charset = $ff62
	JSRFAR = $ff6e
	fetch = $ff74
	stash = $ff77
	PRIMM = $ff7d
	GRAPH_init = $ff20
	GRAPH_clear = $ff23
	GRAPH_set_window = $ff26
	GRAPH_set_colors = $ff29
	GRAPH_draw_line = $ff2c
	GRAPH_draw_rect = $ff2f
	GRAPH_move_rect = $ff32
	GRAPH_draw_oval = $ff35
	GRAPH_draw_image = $ff38
	GRAPH_set_font = $ff3b
	GRAPH_get_char_size = $ff3e
	GRAPH_put_char = $ff41
	GRAPH_put_next_char = $ff41
	FB_init = $fef6
	FB_get_info = $fef9
	FB_set_palette = $fefc
	FB_cursor_position = $feff
	FB_cursor_next_line = $ff02
	FB_get_pixel = $ff05
	FB_get_pixels = $ff08
	FB_set_pixel = $ff0b
	FB_set_pixels = $ff0e
	FB_set_8_pixels = $ff11
	FB_set_8_pixels_opaque = $ff14
	FB_fill_pixels = $ff17
	FB_filter_pixels = $ff1a
	FB_move_pixels = $ff1d
	i2c_read_byte = $fec6
	i2c_write_byte = $fec9
	i2c_batch_read = $feb4
	i2c_batch_write = $feb7
	sprite_set_image = $fef0
	sprite_set_position = $fef3
	memory_fill = $fee4
	memory_copy = $fee7
	memory_crc = $feea
	memory_decompress = $feed
	console_init = $fedb
	console_put_char = $fede
	console_get_char = $fee1
	console_put_image = $fed8
	console_set_paging_message = $fed5
	entropy_get = $fecf
	extapi = $feab
	monitor = $fecc
	MACPTR = $ff44
	MCIOUT = $feb1
	BSAVE = $feba
	enter_basic = $ff47
	clock_set_date_time = $ff4d
	clock_get_date_time = $ff50
	kbdbuf_peek = $febd
	kbdbuf_get_modifiers = $fec0
	kbdbuf_put = $fec3
	keymap = $fed2
	mouse_config = $ff68
	mouse_get = $ff6b
	mouse_scan = $ff71
	joystick_scan = $ff53
	joystick_get = $ff56
	x16edit_default = $c000
	x16edit_loadfile = $c003
	x16edit_loadfile_options = $c006
	audio_init = $c09f
	bas_fmfreq = $c000
	bas_fmnote = $c003
	bas_fmplaystring = $c006
	bas_fmvib = $c009
	bas_playstringvoice = $c00c
	bas_psgfreq = $c00f
	bas_psgnote = $c012
	bas_psgwav = $c015
	bas_psgplaystring = $c018
	bas_fmchordstring = $c08d
	bas_psgchordstring = $c090
	notecon_bas2fm = $c01b
	notecon_bas2midi = $c01e
	notecon_bas2psg = $c021
	notecon_fm2bas = $c024
	notecon_fm2midi = $c027
	notecon_fm2psg = $c02a
	notecon_freq2bas = $c02d
	notecon_freq2fm = $c030
	notecon_freq2midi = $c033
	notecon_freq2psg = $c036
	notecon_midi2bas = $c039
	notecon_midi2fm = $c03c
	notecon_midi2psg = $c03f
	notecon_psg2bas = $c042
	notecon_psg2fm = $c045
	notecon_psg2midi = $c048
	psg_init = $c04b
	psg_playfreq = $c04e
	psg_read = $c051
	psg_setatten = $c054
	psg_setfreq = $c057
	psg_setpan = $c05a
	psg_setvol = $c05d
	psg_write = $c060
	psg_write_fast = $c0a2
	psg_getatten = $c093
	psg_getpan = $c096
	ym_init = $c063
	ym_loaddefpatches = $c066
	ym_loadpatch = $c069
	ym_loadpatchlfn = $c06c
	ym_playdrum = $c06f
	ym_playnote = $c072
	ym_setatten = $c075
	ym_setdrum = $c078
	ym_setnote = $c07b
	ym_setpan = $c07e
	ym_read = $c081
	ym_release = $c084
	ym_trigger = $c087
	ym_write = $c08a
	ym_getatten = $c099
	ym_getpan = $c09c
	ym_get_chip_type = $c0a5


































































































































set_screen_mode	.proc
        clc
        jmp  screen_mode
	.pend

get_screen_mode	.proc
        sec
        jmp  screen_mode
	.pend

mouse_config2	.proc
        pha                         ; save shape
        sec
        jsr  cx16.screen_mode       ; set current screen mode and res in A, X, Y
        pla                         ; get shape back
        jmp  cx16.mouse_config
	.pend

mouse_pos	.proc
        ldx  #cx16.r0
        jmp  cx16.mouse_get
	.pend

mouse_set_pos	.proc
        ldx  #cx16.r0L
        lda  #EXTAPI_mouse_set_position
        jmp  cx16.extapi
	.pend

mouse_set_sprite_offset	.proc
        clc
        lda  #EXTAPI_mouse_sprite_offset
        jmp  cx16.extapi
	.pend

mouse_get_sprite_offset	.proc
        sec
        lda  #EXTAPI_mouse_sprite_offset
        jmp  cx16.extapi
	.pend

getlfs	.proc
        lda  #EXTAPI_mouse_set_position
        jmp  cx16.extapi
	.pend

iso_cursor_char	.proc
        clc
        lda  #EXTAPI_iso_cursor_char
        jmp  cx16.extapi
	.pend

numbanks	.proc
        sec
        jsr  cbm.MEMTOP
        ldy  #0
        cmp  #0
        bne  +
        iny
+       rts
	.pend

vpeek	.proc
                stz  cx16.VERA_CTRL
                sta  cx16.VERA_ADDR_H
                sty  cx16.VERA_ADDR_M
                stx  cx16.VERA_ADDR_L
                lda  cx16.VERA_DATA0
                rts
	.pend

vaddr	.proc
            pha
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            pla
            cpy  #0
            bmi  ++
            beq  +
            ora  #%00010000
+           sta  cx16.VERA_ADDR_H
            rts
+           ora  #%00011000
            sta  cx16.VERA_ADDR_H
            rts
	.pend

vaddr_clone	.proc
        sta  VERA_CTRL
        ldx  VERA_ADDR_L
        ldy  VERA_ADDR_H
        phy
        ldy  VERA_ADDR_M
        eor  #1
        sta  VERA_CTRL
        stx  VERA_ADDR_L
        sty  VERA_ADDR_M
        ply
        sty  VERA_ADDR_H
        eor  #1
        sta  VERA_CTRL
        rts
	.pend

vaddr_autoincr	.proc
            jsr  _setup
            lda  cx16.r2H
            ora  cx16.r2L
            beq  +
            jsr  _determine_incr_bits
+           ora  P8ZP_SCRATCH_REG
            sta  cx16.VERA_ADDR_H
            rts

_setup      sta  P8ZP_SCRATCH_REG
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            rts

_determine_incr_bits
            lda  cx16.r2H
            bne  _large
            lda  cx16.r2L
            ldy  #13
-           cmp  _strides_lsb,y
            beq  +
            dey
            bpl  -
+           tya
            asl  a
            asl  a
            asl  a
            asl  a
            rts
_large      ora  cx16.r2L
            cmp  #1         ; 256
            bne  +
            lda  #9<<4
            rts
+           cmp  #2         ; 512
            bne  +
            lda  #10<<4
            rts
+           cmp  #65        ; 320
            bne  +
            lda  #14<<4
            rts
+           cmp  #130       ; 640
            bne  +
            lda  #15<<4
            rts
+           lda  #0
            rts
_strides_lsb    .byte   0,1,2,4,8,16,32,64,128,255,255,40,80,160,255,255
	.pend

vaddr_autodecr	.proc
            jsr  vaddr_autoincr._setup
            lda  cx16.r2H
            ora  cx16.r2L
            beq  +
            jsr  vaddr_autoincr._determine_incr_bits
            ora  #%00001000         ; autodecrement
+           ora  P8ZP_SCRATCH_REG
            sta  cx16.VERA_ADDR_H
            rts
	.pend

vpoke	.proc
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        sty  cx16.VERA_DATA0
        rts
	.pend

vpoke_or	.proc
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        ora  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend

vpoke_and	.proc
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        and  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend

vpoke_xor	.proc
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        eor  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend

vpoke_mask	.proc
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        txa
        and  cx16.VERA_DATA0
        ora  P8ZP_SCRATCH_B1
        sta  cx16.VERA_DATA0
        rts
	.pend

save_virtual_registers	.proc
        ldy  #31
-       lda  cx16.r0,y
        sta  _cx16_vreg_storage,y
        dey
        bpl  -
        rts

_cx16_vreg_storage
        .word 0,0,0,0,0,0,0,0
        .word 0,0,0,0,0,0,0,0
	.pend

restore_virtual_registers	.proc
        ldy  #31
-       lda  save_virtual_registers._cx16_vreg_storage,y
        sta  cx16.r0,y
        dey
        bpl  -
        rts
	.pend

save_vera_context	.proc
        ; note cannot store this on cpu hardware stack because this gets called as a subroutine
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+1
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+2
        lda  cx16.VERA_CTRL
        sta  _vera_storage+3
        eor  #1
        sta  _vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage+4
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+5
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+6
        rts
_vera_storage:  .byte 0,0,0,0,0,0,0,0
	.pend

restore_vera_context	.proc
        lda  cx16.save_vera_context._vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.save_vera_context._vera_storage+6
        sta  cx16.VERA_ADDR_H
        lda  cx16.save_vera_context._vera_storage+5
        sta  cx16.VERA_ADDR_M
        lda  cx16.save_vera_context._vera_storage+4
        sta  cx16.VERA_ADDR_L
        lda  cx16.save_vera_context._vera_storage+3
        sta  cx16.VERA_CTRL
        lda  cx16.save_vera_context._vera_storage+2
        sta  cx16.VERA_ADDR_H
        lda  cx16.save_vera_context._vera_storage+1
        sta  cx16.VERA_ADDR_M
        lda  cx16.save_vera_context._vera_storage+0
        sta  cx16.VERA_ADDR_L
        rts
	.pend

set_chrin_keyhandler	.proc
            sei
            sta  P8ZP_SCRATCH_REG
            lda  $00
            pha
            stz  $00
            lda  P8ZP_SCRATCH_REG
            sta  cx16.edkeybk
            stx  cx16.edkeyvec
            sty  cx16.edkeyvec+1
            pla
            sta  $00
            cli
            rts
	.pend

get_chrin_keyhandler	.proc
            sei
            lda  $00
            pha
            stz  $00
            lda  cx16.edkeybk
            sta  cx16.r0L
            lda  cx16.edkeyvec
            ldy  cx16.edkeyvec+1
            sta  cx16.r1
            sty  cx16.r1+1
            pla
            sta  $00
            cli
            rts
	.pend

enable_irq_handlers	.proc
        php
        sei
        bcc  +
        lda  #%00001111
        trb  cx16.VERA_IEN      ; disable all IRQ sources
+       lda  #<_irq_dispatcher
        ldy  #>_irq_dispatcher
        sta  cx16.CINV
        sty  cx16.CINV+1
        plp
        rts

_irq_dispatcher
        ; order of handling: LINE, SPRCOL, AFLOW, VSYNC.
        jsr  sys.save_prog8_internals
        cld
        lda  cx16.VERA_ISR
        and  cx16.VERA_IEN          ; only consider the bits for sources that can actually raise the IRQ

        bit  #2
        beq  +
_mod_line_jump
        jsr  _default_line_handler      ; modified
        ldy  #2
        sty  cx16.VERA_ISR
        bra  _dispatch_end
+
        bit  #4
        beq  +
_mod_sprcol_jump
        jsr  _default_sprcol_handler      ; modified
        ldy  #4
        sty  cx16.VERA_ISR
        bra  _dispatch_end
+
        bit  #8
        beq  +
_mod_aflow_jump
        jsr  _default_aflow_handler      ; modified
        ; note: AFLOW can only be cleared by filling the audio FIFO for at least 1/4. Not via the ISR bit.
        bra  _dispatch_end
+
        bit  #1
        beq  +
_mod_vsync_jump
        jsr  _default_vsync_handler      ; modified
        cmp  #0
        bne  _dispatch_end
        ldy  #1
        sty  cx16.VERA_ISR
        bra  _return_irq
+
        lda  #0
_dispatch_end
        cmp  #0
        beq  _return_irq
        jsr  sys.restore_prog8_internals
		jmp  (sys.restore_irq._orig_irqvec)   ; continue with normal kernal irq routine
_return_irq
        jsr  sys.restore_prog8_internals
		ply
		plx
		pla
		rti

_default_vsync_handler
        lda  #1
        rts
_default_line_handler
        lda  #0
        rts
_default_sprcol_handler
        lda  #0
        rts
_default_aflow_handler
        lda  #0
        rts
	.pend

set_vsync_irq_handler	.proc
        php
        sei
        sta  enable_irq_handlers._mod_vsync_jump+1
        sty  enable_irq_handlers._mod_vsync_jump+2
        lda  #1
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend

set_line_irq_handler	.proc
        php
        sei
        sta  enable_irq_handlers._mod_line_jump+1
        sty  enable_irq_handlers._mod_line_jump+2
        lda  cx16.r0
        ldy  cx16.r0+1
        jsr  sys.set_rasterline
        lda  #2
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend

set_sprcol_irq_handler	.proc
        php
        sei
        sta  enable_irq_handlers._mod_sprcol_jump+1
        sty  enable_irq_handlers._mod_sprcol_jump+2
        lda  #4
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend

set_aflow_irq_handler	.proc
        php
        sei
        sta  enable_irq_handlers._mod_aflow_jump+1
        sty  enable_irq_handlers._mod_aflow_jump+2
        lda  #8
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend

search_x16edit	.proc
; statements
	; inlined routine follows: getrombank
        lda  $01
	; inlined routine end: getrombank
	sta  cx16.r0L
        sei
	lda  #31
	sta  cx16.r1L
label_asm_241_for_loop
	lda  cx16.r1L
	; inlined routine follows: rombank
        sta  $01
	; inlined routine end: rombank
	lda  #<$fff0
	ldy  #>$fff0
	sta  cx16.r2
	sty  cx16.r2+1
	
            ldy  #0
-           lda  signature,y
            cmp  (cx16.r2),y
            bne  +
            iny
            cpy #7
            bne  -
            sec
            bcs  ++
+           clc
+
	bcc  label_asm_243_branch_else
	lda  cx16.r0L
	; inlined routine follows: rombank
        sta  $01
	; inlined routine end: rombank
        cli
	lda  cx16.r1L
	rts
label_asm_243_branch_else
	lda  cx16.r1L
	beq  label_asm_242_for_end
	dec  cx16.r1L
	bra  label_asm_241_for_loop
label_asm_242_for_end
        cli
	lda  #$ff
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables
signature	; PETSCII:"x16edit"
	.byte  $58, $31, $36, $45, $44, $49, $54, $00
	.pend

cpu_is_65816	.proc
			php
			clv
			.byte $e2, $ea  ; SEP #$ea, should be interpreted as 2 NOPs by 6502. 65c816 will set the Overflow flag.
			bvc +
			lda #1
			plp
			rts
+			lda #0
			plp
			rts
	.pend

get_program_args	.proc
            lda  #0
            rol  a
            sta  P8ZP_SCRATCH_REG
            lda  $00
            pha
            stz  $00
            stz  P8ZP_SCRATCH_W1
            lda  #$bf
            sta  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            sta  (cx16.r0),y
            beq  +
_continue   iny
            cpy  cx16.r1L           ; max size?
            bne  -
            beq  ++
+           lda  P8ZP_SCRATCH_REG   ; binary?
            bne  _continue
+           pla
            sta  $00
  rts
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	target = $10



init_system	.proc
        sei
        lda  #0
        tax
        tay
        jsr  cx16.mouse_config  ; disable mouse
        cld
        lda  cx16.VERA_DC_VIDEO
        and  #%00000111 ; retain chroma + output mode
        sta  P8ZP_SCRATCH_REG
        lda  #$0a
        sta  $01        ; rom bank 10 (audio)
        jsr  cx16.audio_init ; silence
        stz  $01        ; rom bank 0 (kernal)
        jsr  cbm.IOINIT
        jsr  cbm.RESTOR
        jsr  cbm.CINT
        lda  cx16.VERA_DC_VIDEO
        and  #%11111000
        ora  P8ZP_SCRATCH_REG
        sta  cx16.VERA_DC_VIDEO  ; restore old output mode
        lda  #$90       ; black
        jsr  cbm.CHROUT
        lda  #1
        jsr  cbm.CHROUT ; swap fg/bg
        lda  #$9e       ; yellow
        jsr  cbm.CHROUT
        lda  #147       ; clear screen
        jsr  cbm.CHROUT
        lda  #8         ; disable charset case switch
        jsr  cbm.CHROUT
        lda  #PROG8_VARSHIGH_RAMBANK
        sta  $00    ; select ram bank
        lda  #0
        tax
        tay
        clc
        clv
        cli
        rts
	.pend

init_system_phase2	.proc
        sei
        lda  cx16.CINV
        sta  restore_irq._orig_irqvec
        lda  cx16.CINV+1
        sta  restore_irq._orig_irqvec+1
        lda  #PROG8_VARSHIGH_RAMBANK
        sta  $00    ; select ram bank
        cli
        rts
	.pend

cleanup_at_exit	.proc
        lda  #1
        sta  $00        ; ram bank 1
        lda  #4
        sta  $01        ; rom bank 4 (basic)
        stz  $2d        ; hack to reset machine code monitor bank to 0
        jsr  cbm.CLRCHN		; reset i/o channels
_exitcodeCarry = *+1
        lda  #0
        lsr  a
_exitcode = *+1
        lda  #0        ; exit code possibly modified in exit()
_exitcodeX = *+1
        ldx  #0
_exitcodeY = *+1
        ldy  #0
        rts
	.pend

set_irq	.proc
        sei
        sta  _modified+1
        sty  _modified+2
        lda  #<_irq_handler
        sta  cx16.CINV
        lda  #>_irq_handler
        sta  cx16.CINV+1
        lda  #1
        tsb  cx16.VERA_IEN      ; enable the vsync irq
        cli
        rts

_irq_handler
        jsr  sys.save_prog8_internals
        cld
_modified
        jsr  $ffff                      ; modified
        pha
		jsr  sys.restore_prog8_internals
		pla
		beq  +
		jmp  (restore_irq._orig_irqvec)   ; continue with normal kernal irq routine
+		lda  #1
		sta  cx16.VERA_ISR      ; clear Vera Vsync irq status
		ply
		plx
		pla
		rti
	.pend

restore_irq	.proc
	    sei
	    lda  _orig_irqvec
	    sta  cx16.CINV
	    lda  _orig_irqvec+1
	    sta  cx16.CINV+1
	    lda  cx16.VERA_IEN
	    and  #%11110000     ; disable all Vera IRQs but the vsync
	    ora  #%00000001
	    sta  cx16.VERA_IEN
	    cli
	    rts
_orig_irqvec    .word  0
	.pend

set_rasterirq	.proc
            sei
            sta  _modified+1
            sty  _modified+2
            lda  cx16.r0
            ldy  cx16.r0+1
            lda  cx16.VERA_IEN
            and  #%11110000     ; disable all irqs but the line(raster) one
            ora  #%00000010
            sta  cx16.VERA_IEN
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  set_rasterline
            lda  #<_raster_irq_handler
            sta  cx16.CINV
            lda  #>_raster_irq_handler
            sta  cx16.CINV+1
            cli
            rts

_raster_irq_handler
            jsr  sys.save_prog8_internals
            cld
_modified   jsr  $ffff    ; modified
            jsr  sys.restore_prog8_internals
            ; end irq processing - don't use kernal's irq handling
            lda  #2
            tsb  cx16.VERA_ISR      ; clear Vera line irq status
            ply
            plx
            pla
            rti
	.pend

set_rasterline	.proc
        php
        sei
        sta  cx16.VERA_IRQLINE_L
        tya
        lsr  a
        bcs  +
        lda  #%10000000
        trb  cx16.VERA_IEN
        plp
        rts
+       lda  #%10000000
        tsb  cx16.VERA_IEN
        plp
        rts
	.pend

reset_system	.proc
            sei
            ldx #$42
            ldy #2
            lda #0
            jmp  cx16.i2c_write_byte
	.pend

wait	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1

_loop       lda  P8ZP_SCRATCH_W1
            ora  P8ZP_SCRATCH_W1+1
            bne  +
            rts

+           sei
            jsr  cbm.RDTIM
            cli
            sta  P8ZP_SCRATCH_B1
-           sei
            jsr  cbm.RDTIM
            cli
            cmp  P8ZP_SCRATCH_B1
            beq  -

            lda  P8ZP_SCRATCH_W1
            bne  +
            dec  P8ZP_SCRATCH_W1+1
+           dec  P8ZP_SCRATCH_W1
            bra  _loop
	.pend

internal_stringcopy	.proc
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend

memcopy	.proc
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            dey
            beq  +
-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            dey
            bne  -
+           lda  (cx16.r0),y
            sta  (cx16.r1),y
            rts

_longcopy
            pha                         ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            iny
            bne  -
            inc  cx16.r0+1
            inc  cx16.r1+1
            dex
            bne  -
            ply
            bne  _copyshort
            rts
	.pend

memset	.proc
            ldy  cx16.r0
            sty  P8ZP_SCRATCH_W1
            ldy  cx16.r0+1
            sty  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend

memsetw	.proc
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            jmp  prog8_lib.memsetw
	.pend

save_prog8_internals	.proc
            lda  P8ZP_SCRATCH_B1
            sta  save_SCRATCH_ZPB1
            lda  P8ZP_SCRATCH_REG
            sta  save_SCRATCH_ZPREG
            lda  P8ZP_SCRATCH_W1
            sta  save_SCRATCH_ZPWORD1
            lda  P8ZP_SCRATCH_W1+1
            sta  save_SCRATCH_ZPWORD1+1
            lda  P8ZP_SCRATCH_W2
            sta  save_SCRATCH_ZPWORD2
            lda  P8ZP_SCRATCH_W2+1
            sta  save_SCRATCH_ZPWORD2+1
            rts
save_SCRATCH_ZPB1	.byte  0
save_SCRATCH_ZPREG	.byte  0
save_SCRATCH_ZPWORD1	.word  0
save_SCRATCH_ZPWORD2	.word  0
	.pend

restore_prog8_internals	.proc
            lda  save_prog8_internals.save_SCRATCH_ZPB1
            sta  P8ZP_SCRATCH_B1
            lda  save_prog8_internals.save_SCRATCH_ZPREG
            sta  P8ZP_SCRATCH_REG
            lda  save_prog8_internals.save_SCRATCH_ZPWORD1
            sta  P8ZP_SCRATCH_W1
            lda  save_prog8_internals.save_SCRATCH_ZPWORD1+1
            sta  P8ZP_SCRATCH_W1+1
            lda  save_prog8_internals.save_SCRATCH_ZPWORD2
            sta  P8ZP_SCRATCH_W2
            lda  save_prog8_internals.save_SCRATCH_ZPWORD2+1
            sta  P8ZP_SCRATCH_W2+1
            rts
	.pend

exit	.proc
            sta  cleanup_at_exit._exitcode
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  cleanup_at_exit
	.pend

exit2	.proc
            sta  cleanup_at_exit._exitcode
            stx  cleanup_at_exit._exitcodeX
            sty  cleanup_at_exit._exitcodeY
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  cleanup_at_exit
	.pend

exit3	.proc
            sta  cleanup_at_exit._exitcode
            lda  #0
            rol  a
            sta  cleanup_at_exit._exitcodeCarry
            stx  cleanup_at_exit._exitcodeX
            sty  cleanup_at_exit._exitcodeY
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  cleanup_at_exit
	.pend
	.pend

; ---- block: 'txt' ----
txt	.proc
	DEFAULT_HEIGHT = $3c
	DEFAULT_WIDTH = $50
	VERA_TEXTMATRIX_ADDR = $b000
	VERA_TEXTMATRIX_BANK = 1

; non-zeropage variables
color_to_charcode	.byte  $90, $05, $1c, $9f, $9c, $1e, $1f, $9e, $81, $95, $96, $97, $98, $99, $9a, $9b
	chrout = $ffd2



column	.proc
        pha
        sec
        jsr  cbm.PLOT
        pla
        tay
        clc
        jmp  cbm.PLOT
	.pend

get_column	.proc
        sec
        jmp cbm.PLOT
	.pend

row	.proc
        pha
        sec
        jsr  cbm.PLOT
        pla
        tax
        clc
        jmp  cbm.PLOT
	.pend

get_row	.proc
        sec
        jmp cbm.PLOT
	.pend

fill_screen	.proc
        sty  _ly+1
        pha
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        lda  #%00010000
        jsr  set_vera_textmatrix_addresses
        pla
_lx     ldx  #0                     ; modified
        phy
_ly     ldy  #1                     ; modified
-       sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        dex
        bne  -
        ply
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       rts

set_vera_textmatrix_addresses:
        stz  cx16.VERA_CTRL
        ora  #VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L       ; start at (0,0)
        lda  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M
        rts
	.pend

clear_screenchars	.proc
        pha
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        pla
_lx     ldx  #0                     ; modified
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       rts
	.pend

clear_screencolors	.proc
        sta  _la+1
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        stz  cx16.VERA_CTRL
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        inc  cx16.VERA_ADDR_L       ; start at (1,0) - the color attribute byte
_lx     ldx  #0                     ; modified
_la     lda  #0                     ; modified
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        lda  #1
        sta  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       rts
	.pend

color	.proc
txtcol 	= 38 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  txtcol
; statements
	lda  #240
	trb  txtcol
	ldy  txtcol
	lda  txt.color_to_charcode,y
	jmp  cbm.CHROUT
; variables
	.section BSS
	.send BSS

	.pend

color2	.proc
txtcol 	= 36 	; zp UBYTE
bgcol 	= 37 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  txtcol
	sty  bgcol
; statements
	lda  #240
	trb  txtcol
	lda  #240
	trb  bgcol
	ldy  bgcol
	lda  txt.color_to_charcode,y
	jsr  cbm.CHROUT
	lda  #1
	jsr  cbm.CHROUT
	ldy  txtcol
	lda  txt.color_to_charcode,y
	jmp  cbm.CHROUT
; variables
	.section BSS
	.send BSS

	.pend

scroll_left	.proc
	    jsr  cbm.SCREEN
	    dex
	    stx  _lx+1
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00010000 | VERA_TEXTMATRIX_BANK        ; auto increment 1
        sta  cx16.VERA_ADDR_H
        lda  #2
        sta  cx16.VERA_ADDR_L   ; begin in column 1
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00010000  | VERA_TEXTMATRIX_BANK         ; auto increment 1
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

_lx     ldx  #0                ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend

scroll_right	.proc
	    jsr  cbm.SCREEN
	    dex
	    stx  _lx+1
	    txa
	    asl  a
	    dea
	    sta  _rcol+1
	    ina
	    ina
	    sta  _rcol2+1
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00011000 | VERA_TEXTMATRIX_BANK        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
_rcol   lda  #79*2-1            ; modified
        sta  cx16.VERA_ADDR_L   ; begin in rightmost column minus one
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00011000 | VERA_TEXTMATRIX_BANK        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
_rcol2  lda  #79*2+1           ; modified
        sta  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

_lx     ldx  #0                 ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend

scroll_up	.proc
	    jsr  cbm.SCREEN
	    stx  _nextline+1
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        lda  #1 | (>VERA_TEXTMATRIX_ADDR)
        sta  cx16.VERA_ADDR_M       ; start at second line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        lda  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at top line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  #80        ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend

scroll_down	.proc
	    jsr  cbm.SCREEN
	    stx  _nextline+1
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        dey
        tya
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at line before bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        iny
        tya
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  #80        ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend

setchr	.proc
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend

getchr	.proc
            asl  a
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend

setclr	.proc
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            ina
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend

getclr	.proc
            asl  a
            ina
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend

plot	.proc
		clc
		jmp  cbm.PLOT
	.pend

width	.proc
        jsr  cbm.SCREEN
        txa
        rts
	.pend

height	.proc
        jsr  cbm.SCREEN
        tya
        rts
	.pend

waitkey	.proc
-       jsr cbm.GETIN
        beq -
        rts
	.pend

chrout_lit	.proc
        tax
        lda  #128
        jsr  cbm.CHROUT
        txa
        jmp  cbm.CHROUT
	.pend

print_lit	.proc
        sta  P8ZP_SCRATCH_W2
        sty  P8ZP_SCRATCH_W2+1
        ldy  #0
-       lda  (P8ZP_SCRATCH_W2),y
        beq  +
        tax
        lda  #128
        jsr  cbm.CHROUT
        txa
        jsr  cbm.CHROUT
        iny
        bne  -
+       rts
	.pend

print	.proc
    		sta  P8ZP_SCRATCH_W2
    		sty  P8ZP_SCRATCH_W2+1
    		ldy  #0
-	    	lda  (P8ZP_SCRATCH_W2),y
    		beq  +
    		jsr  cbm.CHROUT
    		iny
    		bne  -
+	    	rts
	.pend

print_ubhex	.proc
            bcc  +
            pha
            lda  #'$'
            jsr  cbm.CHROUT
            pla
+           jsr  conv.internal_ubyte2hex
            jsr  cbm.CHROUT
            tya
            jmp  cbm.CHROUT
	.pend

print_ubbin	.proc
            sta  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'%'
            jsr  cbm.CHROUT
+           ldy  #8
-           lda  #'0'
            asl  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'1'
+           jsr  cbm.CHROUT
            dey
            bne  -
            rts
	.pend

print_uwbin	.proc
            pha
            tya
            jsr  print_ubbin
            pla
            clc
            jmp  print_ubbin
	.pend

print_uwhex	.proc
            pha
            tya
            jsr  print_ubhex
            pla
            clc
            jmp  print_ubhex
	.pend

print_uw0	.proc
            jsr  conv.internal_uword2decimal
            ldy  #0
-           lda  conv.internal_uword2decimal.decTenThousands,y
            beq  +
            jsr  cbm.CHROUT
            iny
            bne  -
+           rts
	.pend

print_uw	.proc
            jsr  conv.internal_uword2decimal
            ldy  #0
-           lda  conv.internal_uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   jsr  cbm.CHROUT
            iny
            lda  conv.internal_uword2decimal.decTenThousands,y
            bne  _gotdigit
            rts
_allzero    lda  #'0'
            jmp  cbm.CHROUT
	.pend

print_w	.proc
            cpy  #0
            bpl  +
            pha
            lda  #'-'
            jsr  cbm.CHROUT
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+           jmp  print_uw
	.pend

input_chars	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0				; char counter = 0
-           jsr  cbm.CHRIN
            cmp  #$0d			; return (ascii 13) pressed?
            beq  +				; yes, end.
            sta  (P8ZP_SCRATCH_W1),y	; else store char in buffer
            iny
            bne  -
+           lda  #0
            sta  (P8ZP_SCRATCH_W1),y	; finish string with 0 byte
            rts
	.pend

petscii2scr	.proc
            sta  P8ZP_SCRATCH_REG
            lsr  a
            lsr  a
            lsr  a
            lsr  a
            lsr  a
            tax
            lda  _offsets,x
            eor  P8ZP_SCRATCH_REG
            rts
_offsets    .byte  128, 0, 64, 32, 64, 192, 128, 128
	.pend

petscii2scr_str	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  +
            jsr  petscii2scr
            sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
+           rts
	.pend

print_ub0	.proc
            jsr  conv.internal_ubyte2decimal
            pha
            tya
            jsr  cbm.CHROUT
            txa
            jsr  cbm.CHROUT
            pla
            jmp  cbm.CHROUT
	.pend

print_ub	.proc
            jsr  conv.internal_ubyte2decimal
_print_byte_digits
            pha
            cpy  #'0'
            beq  +
            tya
            jsr  cbm.CHROUT
            txa
            jsr  cbm.CHROUT
            jmp  _ones
+           cpx  #'0'
            beq  _ones
            txa
            jsr  cbm.CHROUT
_ones       pla
            jmp  cbm.CHROUT
	.pend

print_b	.proc
            pha
            cmp  #0
            bpl  +
            lda  #'-'
            jsr  cbm.CHROUT
+		    pla
            jsr  conv.internal_byte2decimal
            jmp  print_ub._print_byte_digits
	.pend
	.pend

; ---- block: 'conv' ----
conv	.proc

; non-zeropage variables
string_out	; PETSCII:"????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $00


str_ub0	.proc
            jsr  internal_ubyte2decimal
            sty  conv.string_out
            stx  conv.string_out+1
            sta  conv.string_out+2
            lda  #0
            sta  conv.string_out+3
            lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend

str_ub	.proc
            jsr  internal_ubyte2decimal
            cpy  #'0'
            beq  +
            sty  conv.string_out
            stx  conv.string_out+1
            sta  conv.string_out+2
            lda  #0
            sta  conv.string_out+3
            jmp  _done
+           cpx  #'0'
            beq  +
            stx  conv.string_out
            sta  conv.string_out+1
            lda  #0
            sta  conv.string_out+2
            jmp  _done
+           sta  conv.string_out
            lda  #0
            sta  conv.string_out+1
_done       lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend

str_b	.proc
            cmp  #0
            bpl  str_ub
            eor  #255
            clc
            adc  #1
            jsr  str_ub
            ; insert a minus sign at the start
            lda  #0
            sta  conv.string_out+4
            lda  conv.string_out+2
            sta  conv.string_out+3
            lda  conv.string_out+1
            sta  conv.string_out+2
            lda  conv.string_out
            sta  conv.string_out+1
            lda  #'-'
            sta  conv.string_out
            lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend

str_ubhex	.proc
        jsr  internal_ubyte2hex
        sta  string_out
        sty  string_out+1
        lda  #0
        sta  string_out+2
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend

str_ubbin	.proc
	    sta  P8ZP_SCRATCH_B1
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_B1
        bcc  +
        lda  #'1'
        bne  _digit
+       lda  #'0'
_digit  sta  string_out,y
        dey
	    bpl  -
        lda  #<string_out
        ldy  #>string_out
	    rts
	.pend

str_uwbin	.proc
	    sta  P8ZP_SCRATCH_REG
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_REG
        bcc  +
        lda  #'1'
        bne  _digit
+       lda  #'0'
_digit  sta  string_out+8,y
        dey
	    bpl  -
        lda  #<string_out
        ldy  #>string_out
	    rts
	.pend

str_uwhex	.proc
        pha
        tya
        jsr  internal_ubyte2hex
        sta  string_out
        sty  string_out+1
        pla
        jsr  internal_ubyte2hex
        sta  string_out+2
        sty  string_out+3
        lda  #0
        sta  string_out+4
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend

str_uw0	.proc
	    jsr  conv.internal_uword2decimal
	    ldy  #0
-       lda  conv.internal_uword2decimal.decTenThousands,y
        sta  string_out,y
        beq  +
        iny
        bne  -
+
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend

str_uw	.proc
	    jsr  conv.internal_uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-       lda  internal_uword2decimal.decTenThousands,y
        beq  _allzero
        cmp  #'0'
        bne  _gotdigit
        iny
        bne  -
_gotdigit   sta  string_out,x
        inx
        iny
        lda  internal_uword2decimal.decTenThousands,y
        bne  _gotdigit
_end    lda  #0
        sta  string_out,x
        lda  #<string_out
        ldy  #>string_out
        rts

_allzero    lda  #'0'
        sta  string_out,x
        inx
        bne  _end
	.pend

str_w	.proc
	    cpy  #0
	    bpl  str_uw
	    pha
	    lda  #'-'
	    sta  string_out
        tya
        eor  #255
        tay
        pla
        eor  #255
        clc
        adc  #1
        bcc  +
        iny
+	    jsr  conv.internal_uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
	    rts
	.pend

any2uword	.proc
	pha
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	ldy  P8ZP_SCRATCH_W1+1
	cmp  #'$'
	beq  _hex
	cmp  #'%'
	beq  _bin
	pla
	jsr  str2uword
	jmp  _result
_hex	pla
	jsr  hex2uword
	jmp  _result
_bin	pla
	jsr  bin2uword
_result
        pha
        lda  cx16.r15
        sta  P8ZP_SCRATCH_B1        ; result value
        pla
        sta  cx16.r15
        sty  cx16.r15+1
        lda  P8ZP_SCRATCH_B1
        rts
	.pend

str2uword	.proc
_result = P8ZP_SCRATCH_W1
        	sta  P8ZP_SCRATCH_W2
        	sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  cx16.r15+1
_loop
		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  _result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _loop
		; never reached

_result_times_10     ; (W*4 + W)*2
		lda  _result+1
		sta  P8ZP_SCRATCH_REG
		lda  _result
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  _result
		sta  _result
		lda  P8ZP_SCRATCH_REG
		adc  _result+1
		asl  _result
		rol  a
		sta  _result+1
		rts
	.pend

str2word	.proc
_result = P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  _negative
		sty  cx16.r15+1
		lda  (P8ZP_SCRATCH_W2),y
		cmp  #'+'
		bne  +
		iny
+		cmp  #'-'
		bne  _parse
		inc  _negative
		iny
_parse		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _negative
		beq  +
		sec
		lda  #0
		sbc  _result
		sta  _result
		lda  #0
		sbc  _result+1
		sta  _result+1
+		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  str2uword._result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _parse
		; never reached
_negative	.byte  0
	.pend

hex2uword	.proc
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  P8ZP_SCRATCH_B1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #$0f
	clc
	adc  P8ZP_SCRATCH_B1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
_add_letter
	pha
	lda  #9
	sta  P8ZP_SCRATCH_B1
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
	.pend

bin2uword	.proc
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'%'
	bne  _loop
	iny
_loop
	lda  (P8ZP_SCRATCH_W2),y
	cmp  #'0'
	bcc  _stop
	cmp  #'2'
	bcs  _stop
_first  asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
	.pend

internal_ubyte2decimal	.proc
        ldy #'0'-1
        ldx #'9'+1
        sec
-       iny
        sbc #100
        bcs -
-       dex
        adc #10
        bmi -
        adc #'0'-1
        rts
	.pend

internal_uword2decimal	.proc
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?p=130363&sid=1944ba8bac4d6afa9c02e3cc42304e6b#p130363

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = P8ZP_SCRATCH_B1	; byte in zeropage
hexHigh      	= P8ZP_SCRATCH_W1	; byte in zeropage
hexLow       	= P8ZP_SCRATCH_W1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2 @110/111
    beq    _useZero               ;2 @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2 @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2 @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2 @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

decTenThousands   	.byte  0
decThousands    	.byte  0
decHundreds		.byte  0
decTens			.byte  0
decOnes   		.byte  0
			.byte  0		; zero-terminate the decimal output string
	.pend

internal_byte2decimal	.proc
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  internal_ubyte2decimal
	.pend

internal_ubyte2hex	.proc
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
	.pend

internal_uword2hex	.proc
		sta  P8ZP_SCRATCH_REG
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  P8ZP_SCRATCH_REG
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
output		.text  "0000", $00      ; 0-terminated output buffer (to make printing easier)
	.pend
	.pend

; ---- block: 'diskio' ----
diskio	.proc
	READ_IO_CHANNEL = 12
	WRITE_IO_CHANNEL = 13

; non-zeropage variables without initialization value
	.section BSS
drivenumber	.byte  ?
iteration_in_progress	.byte  ?
list_blocks	.word  ?
list_pattern	.word  ?
list_skip_disk_name	.byte  ?
	.send BSS
; non-zeropage variables
list_filename	; PETSCII:"??????????????????????????????????????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $00
list_filetype	; PETSCII:"???"
	.byte  $3f, $3f, $3f, $00


reset_read_channel	.proc
; statements
	ldx  #12
	jmp  cbm.CHKIN
; variables
	.section BSS
	.send BSS

	.pend

lf_start_list	.proc
; simple int arg(s) passed via register(s)
	sta  pattern_ptr
	sty  pattern_ptr+1
; statements
	jsr  diskio.lf_end_list
	lda  pattern_ptr
	ldy  pattern_ptr+1
	sta  diskio.list_pattern
	sty  diskio.list_pattern+1
	lda  #1
	sta  diskio.list_skip_disk_name
	sta  diskio.iteration_in_progress
	ldy  #>prog8_interned_strings.string_82
	ldx  #<prog8_interned_strings.string_82
	lda  #1
	jsr  cbm.SETNAM
	ldy  #0
	ldx  diskio.drivenumber
	lda  #12
	jsr  cbm.SETLFS
	jsr  cbm.OPEN
	bcs  io_error
	ldx  #12
	jsr  cbm.CHKIN
	lda  #4
	sta  label_asm_246_counter
label_asm_245_repeat
	jsr  cbm.CHRIN
	dec  label_asm_246_counter
	bne  label_asm_245_repeat
	jsr  cbm.READST
	cmp  #0
	bne  label_asm_247_afterif
	lda  #1
	rts
label_asm_247_afterif
io_error
	lda  #12
	jsr  cbm.CLOSE
	jsr  diskio.lf_end_list
	lda  #0
	rts
; variables
	.section BSS
label_asm_246_counter    .byte  ?
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
pattern_ptr	.word  ?
	.send BSS
	.pend

lf_next_entry	.proc
; statements
	lda  diskio.iteration_in_progress
	bne  label_asm_248_afterif
	lda  #0
	rts
label_asm_248_afterif
label_43_repeat
	ldx  #12
	jsr  cbm.CHKIN
	lda  #<diskio.list_filename
	ldy  #>diskio.list_filename
	sta  nameptr
	sty  nameptr+1
	jsr  cbm.CHRIN
	sta  blocks_lsb
	jsr  cbm.CHRIN
	sta  blocks_msb
	jsr  cbm.READST
	cmp  #0
	bne  close_end
	lda  blocks_lsb
	ldy  blocks_msb
	sta  diskio.list_blocks
	sty  diskio.list_blocks+1
label_35_whileloop
	jsr  cbm.CHRIN
	cmp  #34
	beq  label_36_afterwhile
	jsr  cbm.READST
	cmp  #0
	bne  close_end
	bra  label_35_whileloop
label_36_afterwhile
label_39_repeat
	jsr  cbm.CHRIN
	sta  character
	lda  character
	beq  label_37_after
	lda  character
	cmp  #34
	beq  label_38_after
	lda  character
	ldy  nameptr
	sty  P8ZP_SCRATCH_W2
	ldy  nameptr+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  nameptr
	bne  +
	inc  nameptr+1
+
	bra  label_39_repeat
label_38_after
label_37_after
	lda  #0
	ldy  nameptr
	sty  P8ZP_SCRATCH_W2
	ldy  nameptr+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
label_40_untilloop
	jsr  cbm.CHRIN
	sta  cx16.r15L
	cmp  #32
	beq  label_40_untilloop
	lda  cx16.r15L
	sta  diskio.list_filetype+0
	jsr  cbm.CHRIN
	sta  diskio.list_filetype+1
	jsr  cbm.CHRIN
	sta  diskio.list_filetype+2
label_41_whileloop
	jsr  cbm.CHRIN
	cmp  #0
	beq  label_42_afterwhile
	bra  label_41_whileloop
label_42_afterwhile
	jsr  cbm.CHRIN
	jsr  cbm.CHRIN
	lda  diskio.list_skip_disk_name
	bne  label_asm_249_afterif
	lda  diskio.list_pattern
	ora  diskio.list_pattern+1
	bne  label_asm_250_afterif
	lda  #1
	rts
label_asm_250_afterif
	lda  diskio.list_pattern
	sta  cx16.r0
	lda  diskio.list_pattern+1
	sta  cx16.r0+1
	
	ldy  #>diskio.list_filename
	lda  #<diskio.list_filename
	jsr  string.pattern_match
	cmp  #0
	beq  label_asm_251_afterif
	lda  #1
	rts
label_asm_251_afterif
label_asm_249_afterif
	stz  diskio.list_skip_disk_name
	bra  label_43_repeat
close_end
	jsr  diskio.lf_end_list
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
blocks_lsb	.byte  ?
blocks_msb	.byte  ?
character	.byte  ?
nameptr	.word  ?
	.send BSS
	.pend

lf_end_list	.proc
; statements
	lda  diskio.iteration_in_progress
	beq  label_asm_252_afterif
	jsr  cbm.CLRCHN
	lda  #12
	jsr  cbm.CLOSE
	stz  diskio.iteration_in_progress
label_asm_252_afterif
	rts
; variables
	.section BSS
	.send BSS

	.pend

f_readline	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            jsr  reset_read_channel
            ldy  #0
_loop       jsr  cbm.CHRIN
            sta  (P8ZP_SCRATCH_W1),y
            beq  _end
            iny
            cmp  #$0a
            beq  _line_end
            cmp  #$0d
            bne  _loop
_line_end   dey     ; get rid of the trailing end-of-line char
            lda  #0
            sta  (P8ZP_SCRATCH_W1),y
_end        rts
	.pend

vload	.proc
            clc
internal_vload:
            pha
            ldx  drivenumber
            bcc +
            ldy  #%00000010     ; headerless load mode
            bne  ++
+           ldy  #0             ; normal load mode
+           lda  #1
            jsr  cbm.SETLFS
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  prog8_lib.strlen
            tya
            ldx  cx16.r0
            ldy  cx16.r0+1
            jsr  cbm.SETNAM
            pla
            clc
            adc  #2
            ldx  cx16.r1
            ldy  cx16.r1+1
            stz  P8ZP_SCRATCH_B1
            jsr  cbm.LOAD
            bcs  +
            inc  P8ZP_SCRATCH_B1
    +       jsr  cbm.CLRCHN
            lda  #1
            jsr  cbm.CLOSE
            lda  P8ZP_SCRATCH_B1
            rts
	.pend

vload_raw	.proc
            sec
            jmp  vload.internal_vload
	.pend
prog8_init_vars	.block
	lda  #8
	sta  diskio.drivenumber
	stz  diskio.list_skip_disk_name
	stz  diskio.iteration_in_progress
	rts
	.bend
	.pend

; ---- block: 'string' ----
string	.proc



length	.proc
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
	.pend

left	.proc
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		sta  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend

right	.proc
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                stx  P8ZP_SCRATCH_B1
                sta  cx16.r0
                sty  cx16.r0+1
                jsr  string.length
                tya
                sec
                sbc  P8ZP_SCRATCH_B1
                clc
                adc  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_B1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend

slice	.proc
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		; substr(source, target, start, length)
		sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		sta  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1

		; adjust src location
		clc
		lda  P8ZP_SCRATCH_W1
		adc  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		beq  _startloop
-		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
_startloop	dey
		cpy  #$ff
		bne  -
		rts
	.pend

find	.proc
		; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		stx  P8ZP_SCRATCH_B1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  P8ZP_SCRATCH_B1
		beq  _found
		iny
		bne  -
_notfound	lda  #255
        clc
		rts
_found	tya
        sec
        rts
	.pend

contains	.proc
            jmp  find
	.pend

copy	.proc
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend

append	.proc
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  length
            sty  P8ZP_SCRATCH_B1
            tya
            clc
            adc  cx16.r0
            sta  P8ZP_SCRATCH_W1
            lda  cx16.r0+1
            adc  #0
            sta  P8ZP_SCRATCH_W1+1
            lda  cx16.r1
            ldy  cx16.r1+1
            jsr  prog8_lib.strcpy
            tya
            clc
            adc  P8ZP_SCRATCH_B1
            rts
	.pend

compare	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcmp_mem
	.pend

lower	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend

upper	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend

lowerchar	.proc
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           rts
	.pend

upperchar	.proc
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           rts
	.pend

pattern_match	.proc
; pattern matching of a string.
; Input:  cx16.r0:  A NUL-terminated, <255-length pattern
;              AY:  A NUL-terminated, <255-length string
;
; Output: A = 1 if the string matches the pattern, A = 0 if not.
;
; Notes:  Clobbers A, X, Y. Each * in the pattern uses 4 bytes of stack.
;
; see http://6502.org/source/strings/patmatch.htm

strptr = P8ZP_SCRATCH_W1

	sta  strptr
	sty  strptr+1
	lda  cx16.r0
	sta  modify_pattern1+1
	sta  modify_pattern2+1
	lda  cx16.r0+1
	sta  modify_pattern1+2
	sta  modify_pattern2+2
	jsr  _match
	lda  #0
	rol  a
	rts


_match
	ldx #$00        ; x is an index in the pattern
	ldy #$ff        ; y is an index in the string
modify_pattern1
next    lda $ffff,x   ; look at next pattern character    MODIFIED
	cmp #'*'     ; is it a star?
	beq star        ; yes, do the complicated stuff
	iny             ; no, let's look at the string
	cmp #'?'     ; is the pattern caracter a ques?
	bne reg         ; no, it's a regular character
	lda (strptr),y     ; yes, so it will match anything
	beq fail        ;  except the end of string
reg     cmp (strptr),y     ; are both characters the same?
	bne fail        ; no, so no match
	inx             ; yes, keep checking
	cmp #0          ; are we at end of string?
	bne next        ; not yet, loop
found   rts             ; success, return with c=1

star    inx             ; skip star in pattern
modify_pattern2
	cmp $ffff,x   	; string of stars equals one star	MODIFIED
	beq star        ;  so skip them also
stloop  txa             ; we first try to match with * = ""
	pha             ;  and grow it by 1 character every
	tya             ;  time we loop
	pha             ; save x and y on stack
	jsr next        ; recursive call
	pla             ; restore x and y
	tay
	pla
	tax
	bcs found       ; we found a match, return with c=1
	iny             ; no match yet, try to grow * string
	lda (strptr),y     ; are we at the end of string?
	bne stloop      ; not yet, add a character
fail    clc             ; yes, no match found, return with c=0
	rts
	.pend

hash	.proc
            lda  #179
            sta  P8ZP_SCRATCH_REG
            ldy  #0
            clc
-           lda  (cx16.r0),y
            beq  +
            rol  P8ZP_SCRATCH_REG
            eor  P8ZP_SCRATCH_REG
            sta  P8ZP_SCRATCH_REG
            iny
            bne  -
+           lda  P8ZP_SCRATCH_REG
            rts
	.pend

isdigit	.proc
            cmp  #'0'
            bcs  +
            rts
+           cmp  #'9'+1
            bcc  +
            clc
            rts
+           sec
            rts
	.pend

isupper	.proc
            cmp  #97
            bcs  +
            rts
+           cmp  #122+1
            bcc  _yes
            cmp  #193
            bcs  +
            rts
+           cmp  #218+1
            bcc  _yes
            clc
            rts
_yes        sec
            rts
	.pend

islower	.proc
            cmp  #'a'
            bcs  +
            rts
+           cmp  #'z'+1
            bcc  +
            clc
            rts
+           sec
            rts
	.pend

isletter	.proc
            jsr  islower
            bcs  +
            jmp  isupper
+           rts
	.pend

isspace	.proc
            cmp  #32
            beq  +
            cmp  #13
            beq  +
            cmp  #9
            beq  +
            cmp  #10
            beq  +
            cmp  #141
            beq  +
            cmp  #160
            beq  +
            clc
            rts
+           sec
            rts
	.pend

isprint	.proc
            cmp  #160
            bcc  +
            rts
+           cmp  #32
            bcs  +
            rts
+           cmp  #128
            bcc  +
            clc
            rts
+           sec
            rts
	.pend

strip	.proc
s 	= 39 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  s
	sty  s+1
; statements
	jsr  string.rstrip
	ldy  s+1
	lda  s
	jmp  string.lstrip
; variables
	.section BSS
	.send BSS

	.pend

rstrip	.proc
s 	= 41 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  s
	sty  s+1
; statements
	lda  (s)
	bne  label_asm_253_afterif
	rts
label_asm_253_afterif
	ldy  s+1
	lda  s
	jsr  string.length
	sty  cx16.r0L
label_69_untilloop
	dec  cx16.r0L
	ldy  cx16.r0L
	lda  (s),y
	sta  cx16.r1L
	lda  cx16.r0L
	beq  +
	lda  #1
+                           eor  #1
	bne  label_asm_254_shortcut
	lda  cx16.r1L
	jsr  string.isprint
	lda  #0
	rol  a
	beq  label_asm_255_shortcut
	lda  cx16.r1L
	jsr  string.isspace
	lda  #0
	rol  a
	eor  #1
label_asm_255_shortcut
label_asm_254_shortcut
	beq  label_69_untilloop
	lda  #0
	pha
	lda  cx16.r0L
	clc
	adc  #1
	tay
	pla
	sta  (s),y
	rts
; variables
	.section BSS
	.send BSS

	.pend

lstrip	.proc
s 	= 45 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  s
	sty  s+1
; statements
	jsr  string.lstripped
	sta  cx16.r0
	sty  cx16.r0+1
	cmp  string.lstrip.s
	bne  +
	lda  cx16.r0+1
	cmp  string.lstrip.s+1
	beq  label_asm_256_afterif
+
	ldy  s+1
	lda  s
	jsr  string.copy
label_asm_256_afterif
	rts
; variables
	.section BSS
	.send BSS

	.pend

lstripped	.proc
s 	= 43 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  s
	sty  s+1
; statements
	lda  (s)
	bne  label_asm_257_afterif
	ldy  s+1
	lda  s
	rts
label_asm_257_afterif
	lda  #$ff
	sta  cx16.r0L
label_70_untilloop
	inc  cx16.r0L
	ldy  cx16.r0L
	lda  (s),y
	sta  cx16.r1L
	cmp  #0
	beq  +
	lda  #1
+                           eor  #1
	bne  label_asm_258_shortcut
	lda  cx16.r1L
	jsr  string.isprint
	lda  #0
	rol  a
	beq  label_asm_259_shortcut
	lda  cx16.r1L
	jsr  string.isspace
	lda  #0
	rol  a
	eor  #1
label_asm_259_shortcut
label_asm_258_shortcut
	beq  label_70_untilloop
	ldy  s+1
	lda  s
	clc
	adc  cx16.r0L
	bcc  +
	iny
+
	rts
; variables
	.section BSS
	.send BSS

	.pend
	.pend

; ---- block: 'p8b_runcmd' ----
p8b_runcmd	.proc



p8s_do_flupp	.proc
; statements
	ldy  #>prog8_interned_strings.string_87
	lda  #<prog8_interned_strings.string_87
	jsr  txt.print
	lda  #13
	jmp  txt.chrout
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_cls	.proc
; statements
	lda  p8b_main.p8v_graphmode
	cmp  #1
	bne  label_asm_261_else
	lda  p8b_main.p8v_fgcolor
	ldy  p8b_main.p8v_bgcolor
	jsr  p8b_graphics.p8s_clear_screen
	lda  #$93
	jsr  txt.chrout
	bra  label_asm_260_afterif
label_asm_261_else
	lda  #$93
	jsr  txt.chrout
label_asm_260_afterif
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_get	.proc
; statements
	stz  p8v_r
	stz  p8v_v
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  txt.waitkey
	sta  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_r	.byte  ?
p8v_v	.byte  ?
	.send BSS
	.pend

p8s_do_len	.proc
; statements
	stz  p8v_r
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #52
	bne  label_asm_263_else
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_jdarrvars.p8s_get_len
	sta  p8v_v
	sty  p8v_v+1
	bra  label_asm_262_afterif
label_asm_263_else
	lda  p8v_r
	cmp  #53
	bne  label_asm_264_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
label_asm_264_afterif
label_asm_262_afterif
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_joy	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	jsr  cx16.joystick_get
	sta  cx16.r1
	stx  cx16.r1+1
	ldy  cx16.r1+1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.byte  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_peek	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_get_jiffi	.proc
; statements
	stz  p8v_r
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  cbm.RDTIM16
	sta  p8v_v
	sty  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_get_rnd	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #38
	beq  label_asm_265_afterif
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	sta  cx16.r0
	lda  p8v_a+1
	sta  cx16.r0+1
	
	ldy  p8v_a+1
	lda  p8v_a
	jsr  math.rndseed
label_asm_265_afterif
	jsr  math.rndw
	sta  p8v_v
	sty  p8v_v+1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_get_pixel	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_b
	stz  p8v_b+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #38
	beq  label_asm_266_afterif
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	sty  p8v_b+1
label_asm_266_afterif
	lda  p8v_a
	sta  cx16.r0
	lda  p8v_a+1
	sta  cx16.r0+1
	
	lda  p8v_b
	sta  cx16.r1
	lda  p8v_b+1
	sta  cx16.r1+1
	
	jsr  cx16.FB_cursor_position
	jsr  cx16.FB_get_pixel
	sta  p8v_v
	stz  p8v_v+1
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_b	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_poke	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_v
	sty  p8v_v+1
	ldy  p8v_a
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_a+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_vpeek	.proc
	p8c_b = 1
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	ldx  p8v_a
	lda  #1
	jsr  cx16.vpeek
	sta  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_vpoke	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_v
	sty  p8v_v+1
        lda  p8v_a
        sta  cx16.r0
        lda  p8v_a+1
        sta  cx16.r0+1
        ldy  p8v_v
        lda  #1        
        stz  cx16.VERA_CTRL
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        sty  cx16.VERA_DATA0
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_color	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_v
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_268_else
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_v
	lda  p8b_main.p8v_graphmode
	bne  label_asm_270_else
	lda  p8v_a
	ldy  p8v_v
	jsr  txt.color2
	bra  label_asm_269_afterif
label_asm_270_else
	lda  p8v_a
	sta  p8b_main.p8v_fgcolor
	
	lda  p8v_v
	sta  p8b_main.p8v_bgcolor
	
	lda  p8v_a
	ldy  p8v_v
	jsr  p8b_graphics.p8s_colors
label_asm_269_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	bra  label_asm_267_afterif
label_asm_268_else
	lda  p8v_a
	jsr  txt.color
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
label_asm_267_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.byte  ?
p8v_r	.byte  ?
p8v_v	.byte  ?
	.send BSS
	.pend

p8s_do_setchr	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_b
	stz  p8v_v
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_271_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_v
	ldy  p8v_b
	ldx  p8v_a
	lda  p8v_v
	jsr  txt.setchr
label_asm_271_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.byte  ?
p8v_b	.byte  ?
p8v_r	.byte  ?
p8v_v	.byte  ?
	.send BSS
	.pend

p8s_do_setclr	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_b
	stz  p8v_v
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_272_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_v
	ldy  p8v_b
	ldx  p8v_a
	lda  p8v_v
	jsr  txt.setclr
label_asm_272_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.byte  ?
p8v_b	.byte  ?
p8v_r	.byte  ?
p8v_v	.byte  ?
	.send BSS
	.pend

p8s_do_locate	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_b
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_273_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	ldy  p8v_a
	ldx  p8v_b
	jsr  txt.plot
label_asm_273_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.byte  ?
p8v_b	.byte  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_graph	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_v
	stz  p8v_v+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	lda  p8b_runcmd.p8s_do_graph.p8v_a
	cmp  #<1
	bne  label_asm_275_else
	lda  p8b_runcmd.p8s_do_graph.p8v_a+1
	cmp  #>1
	bne  label_asm_275_else
	lda  #1
	sta  p8b_main.p8v_graphmode
	jsr  p8b_graphics.p8s_enable_bitmap_mode
	bra  label_asm_274_afterif
label_asm_275_else
	stz  p8b_main.p8v_graphmode
	jsr  p8b_graphics.p8s_disable_bitmap_mode
label_asm_274_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_do_wait	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	jsr  sys.wait
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_line	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_b
	stz  p8v_c
	stz  p8v_c+1
	stz  p8v_d
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_276_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_c
	sty  p8v_c+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_d
	lda  p8v_a
	ldy  p8v_a+1
	sta  p8b_graphics.p8s_line.p8v_x1
	sty  p8b_graphics.p8s_line.p8v_x1+1
	lda  p8v_b
	sta  p8b_graphics.p8s_line.p8v_y1
	
	lda  p8v_c
	ldy  p8v_c+1
	sta  p8b_graphics.p8s_line.p8v_x2
	sty  p8b_graphics.p8s_line.p8v_x2+1
	lda  p8v_d
	sta  p8b_graphics.p8s_line.p8v_y2
	
	jsr  p8b_graphics.p8s_line
label_asm_276_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_b	.byte  ?
p8v_c	.word  ?
p8v_d	.byte  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_rect	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_b
	stz  p8v_b+1
	stz  p8v_c
	stz  p8v_c+1
	stz  p8v_d
	stz  p8v_d+1
	stz  p8v_e
	stz  p8v_e+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_277_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	sty  p8v_b+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_c
	sty  p8v_c+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_d
	sty  p8v_d+1
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_279_else
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_e
	sty  p8v_e+1
	lda  p8v_a
	ldy  p8v_a+1
	sta  p8b_graphics.p8s_fillrect.p8v_xx
	sty  p8b_graphics.p8s_fillrect.p8v_xx+1
	lda  p8v_b
	ldy  p8v_b+1
	sta  p8b_graphics.p8s_fillrect.p8v_yy
	sty  p8b_graphics.p8s_fillrect.p8v_yy+1
	lda  p8v_c
	ldy  p8v_c+1
	sta  p8b_graphics.p8s_fillrect.p8v_width
	sty  p8b_graphics.p8s_fillrect.p8v_width+1
	lda  p8v_d
	ldy  p8v_d+1
	sta  p8b_graphics.p8s_fillrect.p8v_height
	sty  p8b_graphics.p8s_fillrect.p8v_height+1
	jsr  p8b_graphics.p8s_fillrect
	bra  label_asm_278_afterif
label_asm_279_else
	lda  p8v_a
	ldy  p8v_a+1
	sta  p8b_graphics.p8s_rect.p8v_xx
	sty  p8b_graphics.p8s_rect.p8v_xx+1
	lda  p8v_b
	ldy  p8v_b+1
	sta  p8b_graphics.p8s_rect.p8v_yy
	sty  p8b_graphics.p8s_rect.p8v_yy+1
	lda  p8v_c
	ldy  p8v_c+1
	sta  p8b_graphics.p8s_rect.p8v_width
	sty  p8b_graphics.p8s_rect.p8v_width+1
	lda  p8v_d
	ldy  p8v_d+1
	sta  p8b_graphics.p8s_rect.p8v_height
	sty  p8b_graphics.p8s_rect.p8v_height+1
	jsr  p8b_graphics.p8s_rect
label_asm_278_afterif
label_asm_277_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_b	.word  ?
p8v_c	.word  ?
p8v_d	.word  ?
p8v_e	.word  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_plot	.proc
; statements
	stz  p8v_r
	stz  p8v_a
	stz  p8v_a+1
	stz  p8v_b
	stz  p8v_b+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_a
	sty  p8v_a+1
	lda  (p8b_main.p8v_pcode)
	cmp  #26
	bne  label_asm_280_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_b
	sty  p8v_b+1
	lda  p8v_a
	sta  cx16.r0
	lda  p8v_a+1
	sta  cx16.r0+1
	
	lda  p8v_b
	sta  cx16.r1
	lda  p8v_b+1
	sta  cx16.r1+1
	
	; inlined routine follows: p8s_plot
            jsr  cx16.FB_cursor_position
            lda  p8b_graphics.p8v_stroke_color
            jsr  cx16.FB_set_pixel
	; inlined routine end: p8s_plot
label_asm_280_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_a	.word  ?
p8v_b	.word  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_print	.proc
; statements
	stz  p8v_r
	lda  #1
	sta  p8v_nl
	stz  p8v_v
	stz  p8v_v+1
	stz  p8v_lg
	jsr  p8b_main.p8s_next
	sta  p8v_r
p8l_label_74_untilloop
	lda  p8v_r
	cmp  #26
	bne  label_asm_282_else
	lda  #$20
	jsr  txt.chrout
	jsr  p8b_main.p8s_next
	sta  p8v_r
	bra  label_asm_281_afterif
label_asm_282_else
	lda  p8v_r
	cmp  #27
	bne  label_asm_284_else
	stz  p8v_nl
	jsr  p8b_main.p8s_next
	sta  p8v_r
	bra  label_asm_283_afterif
label_asm_284_else
	lda  p8v_r
	pha
	lda  #<p8v_auto_heap_value_10
	ldy  #>p8v_auto_heap_value_10
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #14
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_286_else
	jsr  p8b_apu.p8s_expr
	sta  p8v_v
	sty  p8v_v+1
	jsr  txt.print_uw
	lda  (p8b_main.p8v_pcode)
	sta  p8v_r
	bra  label_asm_285_afterif
label_asm_286_else
	lda  p8v_r
	cmp  #45
	bne  label_asm_288_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	jsr  string.length
	sty  p8v_lg
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	jsr  txt.print
	lda  p8b_main.p8v_pcode
	clc
	adc  p8v_lg
	sta  p8b_main.p8v_pcode
	bcc  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_main.p8s_next
	sta  p8v_r
	bra  label_asm_287_afterif
label_asm_288_else
	lda  p8v_r
	pha
	lda  #<p8v_auto_heap_value_11
	ldy  #>p8v_auto_heap_value_11
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_73_after
	jsr  p8b_apu.p8s_expr_str
	sta  p8v_v
	sty  p8v_v+1
	jsr  txt.print
	lda  (p8b_main.p8v_pcode)
	sta  p8v_r
label_asm_287_afterif
label_asm_285_afterif
label_asm_283_afterif
label_asm_281_afterif
	lda  p8v_r
	pha
	lda  #<p8v_auto_heap_value_12
	ldy  #>p8v_auto_heap_value_12
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_74_untilloop
p8l_label_73_after
	lda  p8v_nl
	beq  label_asm_289_afterif
	lda  #13
	jsr  txt.chrout
label_asm_289_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_lg	.byte  ?
p8v_nl	.byte  ?
p8v_r	.byte  ?
p8v_v	.word  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_10	.byte  $22, $2c, $2e, $30, $34, $44, $47, $ae, $b0, $bb, $bf, $c4, $c6, $d0
p8v_auto_heap_value_11	.byte  $35, $ca
p8v_auto_heap_value_12	.byte  $00, $19, $7f
	.pend
	.pend

; ---- block: 'p8b_graphics' ----
p8b_graphics	.proc
	p8c_HEIGHT = $f0
	p8c_WIDTH = $0140

; non-zeropage variables without initialization value
	.section BSS
p8v_background_color	.byte  ?
p8v_stroke_color	.byte  ?
	.send BSS
	p8s_FB_cursor_position2 = $feff



p8s_enable_bitmap_mode	.proc
; statements
	lda  #$80
	clc
	jsr  cx16.screen_mode
	stz  cx16.r0
	stz  cx16.r0+1
	jsr  cx16.GRAPH_init
	lda  #1
	ldy  #0
	jmp  p8b_graphics.p8s_clear_screen
; variables
	.section BSS
	.send BSS

	.pend

p8s_disable_bitmap_mode	.proc
; statements
	lda  #0
	clc
	jsr  cx16.screen_mode
	lda  #$93
	jmp  txt.chrout
; variables
	.section BSS
	.send BSS

	.pend

p8s_clear_screen	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_pixelcolor
	sty  p8v_bgcolor
; statements
	sta  p8b_graphics.p8v_stroke_color
	
	lda  p8v_bgcolor
	sta  p8b_graphics.p8v_background_color
	
	ldy  p8v_bgcolor
	ldx  p8v_pixelcolor
	lda  p8v_pixelcolor
	jsr  cx16.GRAPH_set_colors
	jmp  cx16.GRAPH_clear
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_bgcolor	.byte  ?
p8v_pixelcolor	.byte  ?
	.send BSS
	.pend

p8s_colors	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_stroke
	sty  p8v_fill
; statements
	ldy  p8b_graphics.p8v_background_color
	ldx  p8v_fill
	lda  p8v_stroke
	jsr  cx16.GRAPH_set_colors
	lda  p8v_stroke
	sta  p8b_graphics.p8v_stroke_color
	
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_fill	.byte  ?
p8v_stroke	.byte  ?
	.send BSS
	.pend

p8s_line	.proc
; statements
	lda  p8v_x1
	sta  cx16.r0
	lda  p8v_x1+1
	sta  cx16.r0+1
	
	lda  p8v_y1
	sta  cx16.r1
	stz  cx16.r1+1
	lda  p8v_x2
	sta  cx16.r2
	lda  p8v_x2+1
	sta  cx16.r2+1
	
	lda  p8v_y2
	sta  cx16.r3
	stz  cx16.r3+1
	jmp  cx16.GRAPH_draw_line
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_x1	.word  ?
p8v_x2	.word  ?
p8v_y1	.byte  ?
p8v_y2	.byte  ?
	.send BSS
	.pend

p8s_fillrect	.proc
; statements
	lda  p8v_xx
	sta  cx16.r0
	lda  p8v_xx+1
	sta  cx16.r0+1
	
	lda  p8v_yy
	sta  cx16.r1
	lda  p8v_yy+1
	sta  cx16.r1+1
	
	lda  p8v_width
	sta  cx16.r2
	lda  p8v_width+1
	sta  cx16.r2+1
	
	lda  p8v_height
	sta  cx16.r3
	lda  p8v_height+1
	sta  cx16.r3+1
	
	stz  cx16.r4
	stz  cx16.r4+1
	sec
	jmp  cx16.GRAPH_draw_rect
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_height	.word  ?
p8v_width	.word  ?
p8v_xx	.word  ?
p8v_yy	.word  ?
	.send BSS
	.pend

p8s_rect	.proc
; statements
	lda  p8v_xx
	sta  cx16.r0
	lda  p8v_xx+1
	sta  cx16.r0+1
	
	lda  p8v_yy
	sta  cx16.r1
	lda  p8v_yy+1
	sta  cx16.r1+1
	
	lda  p8v_width
	sta  cx16.r2
	lda  p8v_width+1
	sta  cx16.r2+1
	
	lda  p8v_height
	sta  cx16.r3
	lda  p8v_height+1
	sta  cx16.r3+1
	
	stz  cx16.r4
	stz  cx16.r4+1
	clc
	jmp  cx16.GRAPH_draw_rect
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_height	.word  ?
p8v_width	.word  ?
p8v_xx	.word  ?
p8v_yy	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	lda  #1
	sta  p8b_graphics.p8v_stroke_color
	rts
	.bend
	.pend

; ---- block: 'p8b_apu' ----
p8b_apu	.proc

; non-zeropage variables
p8v_strbuf	; ISO:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
p8v_strchr	; ISO:"\x00\x00"
	.byte  $00, $00, $00


p8s_relation	.proc
; statements
	stz  p8v_r1
	stz  p8v_r1+1
	stz  p8v_r2
	stz  p8v_r2+1
	stz  p8v_r3
	stz  p8v_op4
	jsr  p8b_apu.p8s_expr
	sta  p8v_r1
	sty  p8v_r1+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op4
	lda  #13
	jsr  txt.chrout
	ldy  #>prog8_interned_strings.string_90
	lda  #<prog8_interned_strings.string_90
	jsr  txt.print
	ldy  p8v_r1+1
	lda  p8v_r1
	sec
	jsr  txt.print_uwhex
	ldy  #>prog8_interned_strings.string_91
	lda  #<prog8_interned_strings.string_91
	jsr  txt.print
	lda  p8v_op4
	sec
	jsr  txt.print_ubhex
	lda  #13
	jsr  txt.chrout
p8l_label_79_whileloop
	lda  p8v_op4
	pha
	lda  #<p8v_auto_heap_value_13
	ldy  #>p8v_auto_heap_value_13
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_80_afterwhile
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_r2
	sty  p8v_r2+1
	lda  p8v_op4
	cmp  #39
	bne  label_asm_291_else
	stz  p8v_r3
	ldy  p8v_r1+1
	lda  p8v_r1
	cmp  p8v_r2
	tya
	sbc  p8v_r2+1
	bcs  label_asm_292_afterif
	lda  #1
	sta  p8v_r3
label_asm_292_afterif
	bra  label_asm_290_afterif
label_asm_291_else
	lda  p8v_op4
	cmp  #40
	bne  label_asm_294_else
	stz  p8v_r3
	ldy  p8v_r2+1
	lda  p8v_r2
	cmp  p8v_r1
	tya
	sbc  p8v_r1+1
	bcs  label_asm_295_afterif
	lda  #1
	sta  p8v_r3
label_asm_295_afterif
	bra  label_asm_293_afterif
label_asm_294_else
	lda  p8v_op4
	cmp  #41
	bne  label_asm_296_afterif
	stz  p8v_r3
	lda  p8b_apu.p8s_relation.p8v_r1
	cmp  p8b_apu.p8s_relation.p8v_r2
	bne  label_asm_297_afterif
	lda  p8b_apu.p8s_relation.p8v_r1+1
	cmp  p8b_apu.p8s_relation.p8v_r2+1
	bne  label_asm_297_afterif
	lda  #1
	sta  p8v_r3
label_asm_297_afterif
label_asm_296_afterif
label_asm_293_afterif
label_asm_290_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op4
	bra  p8l_label_79_whileloop
p8l_label_80_afterwhile
	lda  p8v_r3
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_op4	.byte  ?
p8v_r1	.word  ?
p8v_r2	.word  ?
p8v_r3	.byte  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_13	.byte  $27, $28, $29
	.pend

p8s_get_number	.proc
; statements
	stz  p8v_n
	stz  p8v_n+1
	stz  p8v_m
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_n
	sty  p8v_n+1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_l	.byte  ?
p8v_m	.byte  ?
p8v_n	.word  ?
	.send BSS
	.pend

p8s_varfactor	.proc
; statements
	stz  p8v_v
	stz  p8v_v+1
	stz  p8v_v1
	stz  p8v_v1+1
	stz  p8v_n
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op3
	cmp  #46
	bne  label_asm_299_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  P8ZP_SCRATCH_W2
	stz  P8ZP_SCRATCH_W2+1
	lda  (P8ZP_SCRATCH_W2)
	ldy  #0
	sta  p8v_v
	sty  p8v_v+1
	bra  label_asm_298_afterif
label_asm_299_else
	lda  p8v_op3
	pha
	lda  #<p8v_auto_heap_value_14
	ldy  #>p8v_auto_heap_value_14
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_301_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	jsr  p8b_jdvars.p8s_get_value
	sta  p8v_v
	sty  p8v_v+1
	bra  label_asm_300_afterif
label_asm_301_else
	lda  p8v_op3
	cmp  #52
	bne  label_asm_303_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_n
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_n
	jsr  p8b_callstack_b.p8s_push
	jsr  p8b_apu.p8s_expr
	sta  p8v_v1
	sty  p8v_v1+1
	jsr  p8b_callstack_b.p8s_pop
	sta  p8v_n
	sta  p8b_jdarrvars.p8s_get_value.p8v_nr
	
	lda  p8v_v1
	ldy  p8v_v1+1
	sta  p8b_jdarrvars.p8s_get_value.p8v_index
	sty  p8b_jdarrvars.p8s_get_value.p8v_index+1
	jsr  p8b_jdarrvars.p8s_get_value
	sta  p8v_v
	sty  p8v_v+1
	bra  label_asm_302_afterif
label_asm_303_else
	lda  p8v_op3
	cmp  #180
	bne  label_asm_305_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_runlang.p8v_funcno
	sta  p8b_runlang.p8v_varname
	lda  (p8b_main.p8v_pcode)
	sta  p8b_runlang.p8v_varname+1
	ldy  #>p8b_runlang.p8v_varname
	lda  #<p8b_runlang.p8v_varname
	jsr  p8b_jdlocal.p8s_get_name
	sta  p8v_n
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8v_n
	jsr  p8b_callstack_b.p8s_push
	jsr  p8b_apu.p8s_expr
	sta  p8v_v1
	sty  p8v_v1+1
	jsr  p8b_callstack_b.p8s_pop
	sta  p8v_n
	sta  p8b_jdarrvars.p8s_get_value.p8v_nr
	
	lda  p8v_v1
	ldy  p8v_v1+1
	sta  p8b_jdarrvars.p8s_get_value.p8v_index
	sty  p8b_jdarrvars.p8s_get_value.p8v_index+1
	jsr  p8b_jdarrvars.p8s_get_value
	sta  p8v_v
	sty  p8v_v+1
	bra  label_asm_304_afterif
label_asm_305_else
	lda  p8v_op3
	pha
	lda  #<p8v_auto_heap_value_15
	ldy  #>p8v_auto_heap_value_15
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_306_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_runlang.p8v_funcno
	sta  p8b_runlang.p8v_varname
	lda  (p8b_main.p8v_pcode)
	sta  p8b_runlang.p8v_varname+1
	ldy  #>p8b_runlang.p8v_varname
	lda  #<p8b_runlang.p8v_varname
	jsr  p8b_jdlocal.p8s_get_name
	sta  p8v_v
	sty  p8v_v+1
label_asm_306_afterif
label_asm_304_afterif
label_asm_302_afterif
label_asm_300_afterif
label_asm_298_afterif
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_n	.byte  ?
p8v_op3	.byte  ?
p8v_v	.word  ?
p8v_v1	.word  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_14	.byte  $30, $44
p8v_auto_heap_value_15	.byte  $ae, $b0, $c4
	.pend

p8s_factor	.proc
; statements
	stz  p8v_r
	stz  p8v_r+1
	stz  p8v_r1
	stz  p8v_r1+1
	stz  p8v_op2
	stz  p8v_lfunc
	stz  p8v_ind
	ldy  p8v_r+1
	lda  p8v_r
	jsr  p8b_callstack_w.p8s_push
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op2
	cmp  #44
	bne  label_asm_308_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_get_number
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_307_afterif
label_asm_308_else
	lda  p8v_op2
	cmp  #12
	bne  label_asm_310_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	cmp  #44
	bne  label_asm_312_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_get_number
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_311_afterif
label_asm_312_else
	jsr  p8b_apu.p8s_varfactor
	sta  p8v_r
	sty  p8v_r+1
label_asm_311_afterif
	lda  p8v_r
	eor  #255
	sta  p8v_r
	lda  p8v_r+1
	eor  #255
	sta  p8v_r+1
	bra  label_asm_309_afterif
label_asm_310_else
	lda  p8v_op2
	cmp  #34
	bne  label_asm_314_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_r
	sty  p8v_r+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_313_afterif
label_asm_314_else
	lda  p8v_op2
	cmp  #71
	bne  label_asm_316_else
	lda  #0
	jsr  p8b_runlang.p8s_do_callfunc
	sta  p8v_r
	sty  p8v_r+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	bra  label_asm_315_afterif
label_asm_316_else
	lda  p8v_op2
	cmp  #199
	bne  label_asm_318_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_runlang.p8v_funcno
	sta  p8b_runlang.p8v_varname
	lda  #1
	sta  p8b_runlang.p8v_varname+1
	ldy  #>p8b_runlang.p8v_varname
	lda  #<p8b_runlang.p8v_varname
	jsr  p8b_jdlocal.p8s_get_indexbyname
	sta  p8v_ind
	jsr  p8b_jdlocal.p8s_get_value
	sta  p8v_lfunc
	jsr  p8b_runlang.p8s_do_callfunc
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_317_afterif
label_asm_318_else
	lda  p8v_op2
	cmp  #72
	bne  label_asm_320_else
	jsr  p8b_runcmd.p8s_do_peek
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_319_afterif
label_asm_320_else
	lda  p8v_op2
	cmp  #74
	bne  label_asm_322_else
	jsr  p8b_runcmd.p8s_do_vpeek
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_321_afterif
label_asm_322_else
	lda  p8v_op2
	cmp  #186
	bne  label_asm_324_else
	jsr  p8b_runcmd.p8s_do_get
	sta  p8v_r
	stz  p8v_r+1
	bra  label_asm_323_afterif
label_asm_324_else
	lda  p8v_op2
	cmp  #208
	bne  label_asm_326_else
	jsr  p8b_runcmd.p8s_do_get_pixel
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_325_afterif
label_asm_326_else
	lda  p8v_op2
	cmp  #187
	bne  label_asm_328_else
	jsr  p8b_runcmd.p8s_do_len
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_327_afterif
label_asm_328_else
	lda  p8v_op2
	cmp  #191
	bne  label_asm_330_else
	jsr  p8b_runcmd.p8s_do_get_jiffi
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_329_afterif
label_asm_330_else
	lda  p8v_op2
	cmp  #198
	bne  label_asm_332_else
	jsr  p8b_runcmd.p8s_do_get_rnd
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_331_afterif
label_asm_332_else
	lda  p8v_op2
	cmp  #200
	bne  label_asm_334_else
	jsr  p8b_runcmd.p8s_do_joy
	sta  p8v_r
	sty  p8v_r+1
	bra  label_asm_333_afterif
label_asm_334_else
	jsr  p8b_apu.p8s_varfactor
	sta  p8v_r
	sty  p8v_r+1
label_asm_333_afterif
label_asm_331_afterif
label_asm_329_afterif
label_asm_327_afterif
label_asm_325_afterif
label_asm_323_afterif
label_asm_321_afterif
label_asm_319_afterif
label_asm_317_afterif
label_asm_315_afterif
label_asm_313_afterif
label_asm_309_afterif
label_asm_307_afterif
	lda  p8v_r
	ldy  p8v_r+1
	sta  p8v_r1
	sty  p8v_r1+1
	jsr  p8b_callstack_w.p8s_pop
	sta  p8v_r
	sty  p8v_r+1
	ldy  p8v_r1+1
	lda  p8v_r1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_ind	.byte  ?
p8v_lfunc	.byte  ?
p8v_op2	.byte  ?
p8v_r	.word  ?
p8v_r1	.word  ?
	.send BSS
	.pend

p8s_term	.proc
; statements
	stz  p8v_f1
	stz  p8v_f1+1
	stz  p8v_f2
	stz  p8v_f2+1
	stz  p8v_f3
	stz  p8v_f3+1
	stz  p8v_op1
	ldy  p8v_f1+1
	lda  p8v_f1
	jsr  p8b_callstack_w.p8s_push
	ldy  p8v_f2+1
	lda  p8v_f2
	jsr  p8b_callstack_w.p8s_push
	jsr  p8b_apu.p8s_factor
	sta  p8v_f1
	sty  p8v_f1+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op1
p8l_label_81_whileloop
	lda  p8v_op1
	pha
	lda  #<p8v_auto_heap_value_16
	ldy  #>p8v_auto_heap_value_16
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_82_afterwhile
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_factor
	sta  p8v_f2
	sty  p8v_f2+1
	lda  p8v_op1
	cmp  #31
	bne  label_asm_336_else
	lda  p8v_f2
	ldy  p8v_f2+1
	sta  math.multiply_words.multiplier
	sty  math.multiply_words.multiplier+1
	lda  p8v_f1
	ldy  p8v_f1+1
	jsr  math.multiply_words
	sta  p8v_f1
	sty  p8v_f1+1
	bra  label_asm_335_afterif
label_asm_336_else
	lda  p8v_op1
	cmp  #32
	bne  label_asm_338_else
	lda  p8v_f1
	ldy  p8v_f1+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  p8v_f2
	ldy  p8v_f2+1
	jsr  math.divmod_uw_asm
	sta  p8v_f1
	sty  p8v_f1+1
	bra  label_asm_337_afterif
label_asm_338_else
	lda  p8v_op1
	cmp  #13
	bne  label_asm_339_afterif
	lda  p8v_f1
	ldy  p8v_f1+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  p8v_f2
	ldy  p8v_f2+1
	jsr  math.divmod_uw_asm
	lda  P8ZP_SCRATCH_W2
	sta  p8v_f1
	lda  P8ZP_SCRATCH_W2+1
	sta  p8v_f1+1
	
label_asm_339_afterif
label_asm_337_afterif
label_asm_335_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op1
	bra  p8l_label_81_whileloop
p8l_label_82_afterwhile
	lda  p8v_f1
	ldy  p8v_f1+1
	sta  p8v_f3
	sty  p8v_f3+1
	jsr  p8b_callstack_w.p8s_pop
	sta  p8v_f2
	sty  p8v_f2+1
	jsr  p8b_callstack_w.p8s_pop
	sta  p8v_f1
	sty  p8v_f1+1
	ldy  p8v_f3+1
	lda  p8v_f3
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_f1	.word  ?
p8v_f2	.word  ?
p8v_f3	.word  ?
p8v_op1	.byte  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_16	.byte  $0d, $1f, $20
	.pend

p8s_expr	.proc
; statements
	stz  p8v_t1
	stz  p8v_t1+1
	stz  p8v_t2
	stz  p8v_t2+1
	stz  p8v_t3
	stz  p8v_t3+1
	stz  p8v_op
	ldy  p8v_t1+1
	lda  p8v_t1
	jsr  p8b_callstack_w.p8s_push
	ldy  p8v_t2+1
	lda  p8v_t2
	jsr  p8b_callstack_w.p8s_push
	jsr  p8b_apu.p8s_term
	sta  p8v_t1
	sty  p8v_t1+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op
p8l_label_83_whileloop
	lda  p8v_op
	pha
	lda  #<p8v_auto_heap_value_17
	ldy  #>p8v_auto_heap_value_17
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #4
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_84_afterwhile
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_term
	sta  p8v_t2
	sty  p8v_t2+1
	lda  p8v_op
	cmp  #$1c
	beq  label_asm_341_choice
	cmp  #$1d
	beq  label_asm_342_choice
	cmp  #10
	beq  label_asm_343_choice
	cmp  #11
	beq  label_asm_344_choice
	bra  label_asm_340_choice_end
label_asm_341_choice
	lda  p8v_t1
	clc
	adc  p8v_t2
	sta  p8v_t1
	lda  p8v_t1+1
	adc  p8v_t2+1
	sta  p8v_t1+1
	bra  label_asm_340_choice_end
label_asm_342_choice
	lda  p8v_t1
	sec
	sbc  p8v_t2
	sta  p8v_t1
	lda  p8v_t1+1
	sbc  p8v_t2+1
	sta  p8v_t1+1
	bra  label_asm_340_choice_end
label_asm_343_choice
	lda  p8v_t1
	and  p8v_t2
	sta  p8v_t1
	lda  p8v_t1+1
	and  p8v_t2+1
	sta  p8v_t1+1
	bra  label_asm_340_choice_end
label_asm_344_choice
	lda  p8v_t1
	ora  p8v_t2
	sta  p8v_t1
	lda  p8v_t1+1
	ora  p8v_t2+1
	sta  p8v_t1+1
label_asm_340_choice_end
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op
	bra  p8l_label_83_whileloop
p8l_label_84_afterwhile
	lda  p8v_t1
	ldy  p8v_t1+1
	sta  p8v_t3
	sty  p8v_t3+1
	jsr  p8b_callstack_w.p8s_pop
	sta  p8v_t2
	sty  p8v_t2+1
	jsr  p8b_callstack_w.p8s_pop
	sta  p8v_t1
	sty  p8v_t1+1
	ldy  p8v_t3+1
	lda  p8v_t3
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_op	.byte  ?
p8v_t1	.word  ?
p8v_t2	.word  ?
p8v_t3	.word  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_17	.byte  $0a, $0b, $1c, $1d
	.pend

p8s_expr_f	.proc
; statements
	stz  p8v_tf1
	stz  p8v_tf1+1
	stz  p8v_tf2
	stz  p8v_tf2+1
	stz  p8v_opf
	jsr  p8b_apu.p8s_term
	sta  p8v_tf1
	sty  p8v_tf1+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_opf
p8l_label_85_whileloop
	lda  p8v_opf
	pha
	lda  #<p8v_auto_heap_value_18
	ldy  #>p8v_auto_heap_value_18
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #4
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_86_afterwhile
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_term
	sta  p8v_tf2
	sty  p8v_tf2+1
	lda  p8v_opf
	cmp  #$1c
	beq  label_asm_346_choice
	cmp  #$1d
	beq  label_asm_347_choice
	cmp  #10
	beq  label_asm_348_choice
	cmp  #11
	beq  label_asm_349_choice
	bra  label_asm_345_choice_end
label_asm_346_choice
	lda  p8v_tf1
	clc
	adc  p8v_tf2
	sta  p8v_tf1
	lda  p8v_tf1+1
	adc  p8v_tf2+1
	sta  p8v_tf1+1
	bra  label_asm_345_choice_end
label_asm_347_choice
	lda  p8v_tf1
	sec
	sbc  p8v_tf2
	sta  p8v_tf1
	lda  p8v_tf1+1
	sbc  p8v_tf2+1
	sta  p8v_tf1+1
	bra  label_asm_345_choice_end
label_asm_348_choice
	lda  p8v_tf1
	and  p8v_tf2
	sta  p8v_tf1
	lda  p8v_tf1+1
	and  p8v_tf2+1
	sta  p8v_tf1+1
	bra  label_asm_345_choice_end
label_asm_349_choice
	lda  p8v_tf1
	ora  p8v_tf2
	sta  p8v_tf1
	lda  p8v_tf1+1
	ora  p8v_tf2+1
	sta  p8v_tf1+1
label_asm_345_choice_end
	lda  (p8b_main.p8v_pcode)
	sta  p8v_opf
	bra  p8l_label_85_whileloop
p8l_label_86_afterwhile
	ldy  p8v_tf1+1
	lda  p8v_tf1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_opf	.byte  ?
p8v_tf1	.word  ?
p8v_tf2	.word  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_18	.byte  $0a, $0b, $1c, $1d
	.pend

p8s_expr_l	.proc
; statements
	stz  p8v_tl1
	stz  p8v_tl1+1
	stz  p8v_tl2
	stz  p8v_tl2+1
	stz  p8v_opl
	jsr  p8b_apu.p8s_term
	sta  p8v_tl1
	sty  p8v_tl1+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_opl
p8l_label_87_whileloop
	lda  p8v_opl
	pha
	lda  #<p8v_auto_heap_value_19
	ldy  #>p8v_auto_heap_value_19
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #4
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_88_afterwhile
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_term
	sta  p8v_tl2
	sty  p8v_tl2+1
	lda  p8v_opl
	cmp  #$1c
	beq  label_asm_351_choice
	cmp  #$1d
	beq  label_asm_352_choice
	cmp  #10
	beq  label_asm_353_choice
	cmp  #11
	beq  label_asm_354_choice
	bra  label_asm_350_choice_end
label_asm_351_choice
	lda  p8v_tl1
	clc
	adc  p8v_tl2
	sta  p8v_tl1
	lda  p8v_tl1+1
	adc  p8v_tl2+1
	sta  p8v_tl1+1
	bra  label_asm_350_choice_end
label_asm_352_choice
	lda  p8v_tl1
	sec
	sbc  p8v_tl2
	sta  p8v_tl1
	lda  p8v_tl1+1
	sbc  p8v_tl2+1
	sta  p8v_tl1+1
	bra  label_asm_350_choice_end
label_asm_353_choice
	lda  p8v_tl1
	and  p8v_tl2
	sta  p8v_tl1
	lda  p8v_tl1+1
	and  p8v_tl2+1
	sta  p8v_tl1+1
	bra  label_asm_350_choice_end
label_asm_354_choice
	lda  p8v_tl1
	ora  p8v_tl2
	sta  p8v_tl1
	lda  p8v_tl1+1
	ora  p8v_tl2+1
	sta  p8v_tl1+1
label_asm_350_choice_end
	lda  (p8b_main.p8v_pcode)
	sta  p8v_opl
	bra  p8l_label_87_whileloop
p8l_label_88_afterwhile
	ldy  p8v_tl1+1
	lda  p8v_tl1
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_opl	.byte  ?
p8v_tl1	.word  ?
p8v_tl2	.word  ?
	.send BSS
; non-zeropage variables
p8v_auto_heap_value_19	.byte  $0a, $0b, $1c, $1d
	.pend

p8s_strvarfactor	.proc
; statements
	stz  p8v_v
	stz  p8v_v+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op6
	cmp  #53
	bne  label_asm_355_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	jsr  p8b_jdstrvars.p8s_get_value
	sta  p8v_v
	sty  p8v_v+1
	inc  p8v_v
	bne  +
	inc  p8v_v+1
+
	inc  p8v_v
	bne  +
	inc  p8v_v+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_355_afterif
	ldy  p8v_v+1
	lda  p8v_v
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_op6	.byte  ?
p8v_v	.word  ?
	.send BSS
	.pend

p8s_strfactor	.proc
; statements
	stz  p8v_r
	stz  p8v_r+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op4
	cmp  #45
	bne  label_asm_357_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8v_r
	sty  p8v_r+1
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	jsr  string.length
	tya
	clc
	adc  #1
	sta  p8v_op4
	lda  p8b_main.p8v_pcode
	clc
	adc  p8v_op4
	sta  p8b_main.p8v_pcode
	bcc  +
	inc  p8b_main.p8v_pcode+1
+
	ldy  p8v_r+1
	lda  p8v_r
	rts
label_asm_357_else
	lda  p8v_op4
	cmp  #192
	bne  label_asm_359_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  label_asm_358_afterif
label_asm_359_else
	lda  p8v_op4
	cmp  #202
	bne  label_asm_361_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_r
	sty  p8v_r+1
	sta  p8b_apu.p8v_strchr
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	ldy  #>p8b_apu.p8v_strchr
	lda  #<p8b_apu.p8v_strchr
	rts
label_asm_361_else
	jsr  p8b_apu.p8s_strvarfactor
	sta  p8v_r
	sty  p8v_r+1
label_asm_360_afterif
label_asm_358_afterif
label_asm_356_afterif
	ldy  p8v_r+1
	lda  p8v_r
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_op4	.byte  ?
p8v_r	.word  ?
	.send BSS
	.pend

p8s_expr_str	.proc
; statements
	stz  p8v_ts1
	stz  p8v_ts1+1
	stz  p8v_ts2
	stz  p8v_ts2+1
	stz  p8v_op5
	stz  p8v_lp
	stz  p8v_lp+1
	stz  p8v_co
	stz  p8v_co+1
	jsr  p8b_apu.p8s_strfactor
	sta  p8v_ts1
	sty  p8v_ts1+1
	lda  #<p8b_apu.p8v_strbuf
	ldy  #>p8b_apu.p8v_strbuf
	sta  p8v_lp
	sty  p8v_lp+1
	stz  p8v_co
	stz  p8v_co+1
p8l_label_89_untilloop
	lda  p8v_ts1
	ldy  p8v_ts1+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8v_ts1
	bne  +
	inc  p8v_ts1+1
+
	inc  p8v_co
	bne  +
	inc  p8v_co+1
+
	lda  p8v_ts1
	ldy  p8v_ts1+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	beq  +
	lda  #1
+                           eor  #1
	bne  label_asm_362_shortcut
	lda  p8b_apu.p8s_expr_str.p8v_co
	cmp  #<255
	bne  label_asm_364_else
	lda  p8b_apu.p8s_expr_str.p8v_co+1
	cmp  #>255
	bne  label_asm_364_else
  lda  #1
	bra  label_asm_363_afterif
label_asm_364_else
  lda  #0
label_asm_363_afterif
label_asm_362_shortcut
	beq  p8l_label_89_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op5
p8l_label_91_whileloop
	lda  p8v_op5
	cmp  #28
	bne  p8l_label_92_afterwhile
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_strfactor
	sta  p8v_ts2
	sty  p8v_ts2+1
	lda  p8v_op5
	cmp  #28
	bne  label_asm_365_afterif
p8l_label_90_untilloop
	lda  p8v_ts2
	ldy  p8v_ts2+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8v_ts2
	bne  +
	inc  p8v_ts2+1
+
	inc  p8v_co
	bne  +
	inc  p8v_co+1
+
	lda  p8v_ts2
	ldy  p8v_ts2+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	beq  +
	lda  #1
+                           eor  #1
	bne  label_asm_366_shortcut
	lda  p8b_apu.p8s_expr_str.p8v_co
	cmp  #<255
	bne  label_asm_368_else
	lda  p8b_apu.p8s_expr_str.p8v_co+1
	cmp  #>255
	bne  label_asm_368_else
  lda  #1
	bra  label_asm_367_afterif
label_asm_368_else
  lda  #0
label_asm_367_afterif
label_asm_366_shortcut
	beq  p8l_label_90_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
label_asm_365_afterif
	lda  (p8b_main.p8v_pcode)
	sta  p8v_op5
	bra  p8l_label_91_whileloop
p8l_label_92_afterwhile
	ldy  #>p8b_apu.p8v_strbuf
	lda  #<p8b_apu.p8v_strbuf
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_co	.word  ?
p8v_lp	.word  ?
p8v_op5	.byte  ?
p8v_ts1	.word  ?
p8v_ts2	.word  ?
	.send BSS
	.pend
	.pend

; ---- block: 'p8b_runlang' ----
p8b_runlang	.proc
p8v_funcvar 	= 55 	; zp UBYTE
p8v_funcno 	= 56 	; zp UBYTE
p8v_funcit 	= 57 	; zp UBYTE

; non-zeropage variables
p8v_varname	; ISO:"\x00\x00"
	.byte  $00, $00, $00


p8s_do_for	.proc
p8v_vt 	= 121 	; zp UBYTE
p8v_vn 	= 212 	; zp UBYTE
p8v_to_v 	= 213 	; zp UWORD
p8v_step_v 	= 215 	; zp UWORD
p8v_from_v 	= 217 	; zp UWORD
; statements
	stz  p8v_from_v
	stz  p8v_from_v+1
	stz  p8v_to_v
	stz  p8v_to_v+1
	stz  p8v_step_v
	stz  p8v_step_v+1
	stz  p8v_vt
	stz  p8v_vn
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_vt
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_vn
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_from_v
	sty  p8v_from_v+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_to_v
	sty  p8v_to_v+1
	lda  (p8b_main.p8v_pcode)
	sta  p8v_step_v
	stz  p8v_step_v+1
	lda  p8b_runlang.p8s_do_for.p8v_step_v
	cmp  #<70
	bne  label_asm_370_else
	lda  p8b_runlang.p8s_do_for.p8v_step_v+1
	cmp  #>70
	bne  label_asm_370_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_step_v
	sty  p8v_step_v+1
	bra  label_asm_369_afterif
label_asm_370_else
	lda  #<1
	ldy  #>1
	sta  p8v_step_v
	sty  p8v_step_v+1
	
label_asm_369_afterif
	lda  p8v_vt
	cmp  #46
	bne  label_asm_372_else
	lda  p8v_from_v
	pha
	lda  p8v_vn
	sta  P8ZP_SCRATCH_W2
	stz  P8ZP_SCRATCH_W2+1
	pla
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_371_afterif
label_asm_372_else
	lda  p8v_vt
	pha
	lda  #<p8v_auto_heap_value_20
	ldy  #>p8v_auto_heap_value_20
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_373_afterif
	lda  p8v_vn
	sta  p8b_jdvars.p8s_set_value.p8v_index
	
	lda  p8v_from_v
	ldy  p8v_from_v+1
	sta  p8b_jdvars.p8s_set_value.p8v_value
	sty  p8b_jdvars.p8s_set_value.p8v_value+1
	jsr  p8b_jdvars.p8s_set_value
label_asm_373_afterif
label_asm_371_afterif
	lda  p8b_main.p8v_pcode
	ldy  p8b_main.p8v_pcode+1
	sta  p8b_forstack.p8s_push.p8v_start_address_code1
	sty  p8b_forstack.p8s_push.p8v_start_address_code1+1
	lda  p8v_vt
	sta  p8b_forstack.p8s_push.p8v_var_type
	
	lda  p8v_vn
	sta  p8b_forstack.p8s_push.p8v_var_num
	
	lda  p8v_from_v
	ldy  p8v_from_v+1
	sta  p8b_forstack.p8s_push.p8v_for_from_val
	sty  p8b_forstack.p8s_push.p8v_for_from_val+1
	lda  p8v_to_v
	ldy  p8v_to_v+1
	sta  p8b_forstack.p8s_push.p8v_for_to_val
	sty  p8b_forstack.p8s_push.p8v_for_to_val+1
	lda  p8v_step_v
	ldy  p8v_step_v+1
	sta  p8b_forstack.p8s_push.p8v_for_step_val
	sty  p8b_forstack.p8s_push.p8v_for_step_val+1
	jsr  p8b_forstack.p8s_push
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables
p8v_auto_heap_value_20	.byte  $30, $44
	.pend

p8s_do_next	.proc
p8v_vt 	= 59 	; zp UBYTE
p8v_vns 	= 60 	; zp UBYTE
p8v_vn 	= 61 	; zp UBYTE
p8v_value 	= 62 	; zp UWORD
p8v_to_v 	= 92 	; zp UWORD
p8v_step_v 	= 94 	; zp UWORD
p8v_f_addr 	= 96 	; zp UWORD
; statements
	stz  p8v_vt
	stz  p8v_vn
	stz  p8v_vns
	stz  p8v_to_v
	stz  p8v_to_v+1
	stz  p8v_f_addr
	stz  p8v_f_addr+1
	stz  p8v_step_v
	stz  p8v_step_v+1
	stz  p8v_value
	stz  p8v_value+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_vt
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_vn
	jsr  p8b_forstack.p8s_pop3
	sta  p8v_vns
	cmp  p8v_vn
	beq  label_asm_374_afterif
	lda  #6
	jsr  p8b_error.p8s_set
label_asm_374_afterif
	jsr  p8b_forstack.p8s_pop5
	sta  p8v_to_v
	sty  p8v_to_v+1
	jsr  p8b_forstack.p8s_pop6
	sta  p8v_step_v
	sty  p8v_step_v+1
	lda  p8v_vt
	cmp  #46
	bne  label_asm_376_else
	lda  p8v_vn
	sta  P8ZP_SCRATCH_W2
	stz  P8ZP_SCRATCH_W2+1
	lda  (P8ZP_SCRATCH_W2)
	ldy  #0
	sta  p8v_value
	sty  p8v_value+1
	bra  label_asm_375_afterif
label_asm_376_else
	lda  p8v_vt
	pha
	lda  #<p8v_auto_heap_value_21
	ldy  #>p8v_auto_heap_value_21
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_377_afterif
	lda  p8v_vn
	jsr  p8b_jdvars.p8s_get_value
	sta  p8v_value
	sty  p8v_value+1
label_asm_377_afterif
label_asm_375_afterif
	lda  p8v_value
	clc
	adc  p8v_step_v
	sta  p8v_value
	lda  p8v_value+1
	adc  p8v_step_v+1
	sta  p8v_value+1
	ldy  p8v_to_v+1
	lda  p8v_to_v
	cmp  p8v_value
	tya
	sbc  p8v_value+1
	bcc  label_asm_379_else
	lda  p8v_vt
	cmp  #46
	bne  label_asm_381_else
	lda  p8v_value
	pha
	lda  p8v_vn
	sta  P8ZP_SCRATCH_W2
	stz  P8ZP_SCRATCH_W2+1
	pla
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_380_afterif
label_asm_381_else
	lda  p8v_vt
	pha
	lda  #<p8v_auto_heap_value_22
	ldy  #>p8v_auto_heap_value_22
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_382_afterif
	lda  p8v_vn
	sta  p8b_jdvars.p8s_set_value.p8v_index
	
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdvars.p8s_set_value.p8v_value
	sty  p8b_jdvars.p8s_set_value.p8v_value+1
	jsr  p8b_jdvars.p8s_set_value
label_asm_382_afterif
label_asm_380_afterif
	jsr  p8b_forstack.p8s_pop1
	sta  p8v_f_addr
	sty  p8v_f_addr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	bra  label_asm_378_afterif
label_asm_379_else
	jsr  p8b_forstack.p8s_pope
	sta  p8v_value
	sty  p8v_value+1
label_asm_378_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables
p8v_auto_heap_value_21	.byte  $30, $44
p8v_auto_heap_value_22	.byte  $30, $44
	.pend

p8s_do_goto	.proc
p8v_value 	= 112 	; zp UWORD
p8v_r 	= 114 	; zp UBYTE
p8v_m 	= 115 	; zp UBYTE
p8v_l 	= 116 	; zp UBYTE
; statements
	stz  p8v_value
	stz  p8v_value+1
	stz  p8v_l
	stz  p8v_m
	stz  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_value
	sty  p8v_value+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_callfunc	.proc
p8v_token 	= 227 	; zp UBYTE
p8v_toaddr 	= 228 	; zp UWORD
p8v_n_t 	= 230 	; zp UBYTE
p8v_n_i 	= 231 	; zp UBYTE
p8v_n_funcvar 	= 232 	; zp UBYTE
p8v_n_funcno 	= 233 	; zp UBYTE
p8v_n_funcit 	= 234 	; zp UBYTE
p8v_lfunc 	= 235 	; zp UBYTE
p8v_lende 	= 236 	; zp BOOL
p8v_cv 	= 237 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  p8v_lfunc
; statements
	stz  p8v_lende
	stz  p8v_cv
	stz  p8v_cv+1
	stz  p8v_toaddr
	stz  p8v_toaddr+1
	stz  p8v_token
	stz  p8v_n_funcno
	stz  p8v_n_funcvar
	stz  p8v_n_funcit
	stz  p8v_n_t
	stz  p8v_n_i
	lda  p8b_runlang.p8v_funcvar
	jsr  p8b_callstack_b.p8s_push
	lda  p8b_runlang.p8v_funcno
	jsr  p8b_callstack_b.p8s_push
	lda  #1
	sta  p8v_n_i
	lda  p8b_runlang.p8v_funcvar
	cmp  p8v_n_i
	bcc  label_asm_384_for_end
	sta  label_asm_385_for_modified+1
label_asm_383_for_loop
	lda  p8b_runlang.p8v_funcno
	sta  p8b_runlang.p8v_varname
	lda  p8v_n_i
	sta  p8b_runlang.p8v_varname+1
	ldy  #>p8b_runlang.p8v_varname
	lda  #<p8b_runlang.p8v_varname
	jsr  p8b_jdlocal.p8s_get_indexbyname
	sta  p8v_n_t
	jsr  p8b_jdlocal.p8s_get_value
	sta  p8v_cv
	sty  p8v_cv+1
	jsr  p8b_callstack_w.p8s_push
	lda  p8v_n_i
label_asm_385_for_modified          cmp  #0         ; modified 
	beq  label_asm_384_for_end
	inc  p8v_n_i
	bra  label_asm_383_for_loop
label_asm_384_for_end
	stz  p8v_n_funcvar
	lda  p8v_lfunc
	beq  label_asm_388_else
	lda  p8v_lfunc
	sta  p8v_n_funcno
	
	bra  label_asm_387_afterif
label_asm_388_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_n_funcno
label_asm_387_afterif
	lda  p8v_n_funcno
	jsr  p8b_jdfunc.p8s_get_stack
	sta  p8v_n_funcit
	inc  p8v_n_funcit
	lda  p8v_n_funcno
	ldy  p8v_n_funcit
	jsr  p8b_jdfunc.p8s_set_stack
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
p8l_label_93_untilloop
	lda  (p8b_main.p8v_pcode)
	pha
	lda  #<p8v_auto_heap_value_23
	ldy  #>p8v_auto_heap_value_23
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #10
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_390_else
	inc  p8v_n_funcvar
	lda  (p8b_main.p8v_pcode)
	pha
	lda  #<p8v_auto_heap_value_24
	ldy  #>p8v_auto_heap_value_24
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_392_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_cv
	stz  p8v_cv+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_n_t
	cmp  #36
	bne  label_asm_394_else
	ldy  #>prog8_interned_strings.string_92
	lda  #<prog8_interned_strings.string_92
	jsr  txt.print
	lda  p8v_n_funcno
	sta  p8b_runlang.p8v_varname
	lda  p8v_n_funcvar
	sta  p8b_runlang.p8v_varname+1
	lda  #<p8b_runlang.p8v_varname
	ldy  #>p8b_runlang.p8v_varname
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_cv
	ldy  p8v_cv+1
	sta  p8b_jdlocal.p8s_insert.p8v_value
	sty  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
	bra  label_asm_393_afterif
label_asm_394_else
	ldy  #>prog8_interned_strings.string_93
	lda  #<prog8_interned_strings.string_93
	jsr  txt.print
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	jsr  p8b_apu.p8s_expr_f
	sta  p8v_cv
	sty  p8v_cv+1
	sec
	jsr  txt.print_uwhex
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_n_funcno
	sta  p8b_runlang.p8v_varname
	lda  p8v_n_funcvar
	sta  p8b_runlang.p8v_varname+1
	lda  #<p8b_runlang.p8v_varname
	ldy  #>p8b_runlang.p8v_varname
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_cv
	ldy  p8v_cv+1
	sta  p8b_jdlocal.p8s_insert.p8v_value
	sty  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
label_asm_393_afterif
	bra  label_asm_391_afterif
label_asm_392_else
	lda  p8v_n_funcno
	jsr  p8b_callstack_b.p8s_push
	lda  p8v_n_funcvar
	jsr  p8b_callstack_b.p8s_push
	jsr  p8b_apu.p8s_expr
	sta  p8v_cv
	sty  p8v_cv+1
	jsr  p8b_callstack_b.p8s_pop
	sta  p8v_n_funcvar
	jsr  p8b_callstack_b.p8s_pop
	sta  p8v_n_funcno
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	lda  p8v_n_funcno
	sta  p8b_runlang.p8v_varname
	lda  p8v_n_funcvar
	sta  p8b_runlang.p8v_varname+1
	lda  #<p8b_runlang.p8v_varname
	ldy  #>p8b_runlang.p8v_varname
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_cv
	ldy  p8v_cv+1
	sta  p8b_jdlocal.p8s_insert.p8v_value
	sty  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
label_asm_391_afterif
	bra  label_asm_389_afterif
label_asm_390_else
	lda  (p8b_main.p8v_pcode)
	cmp  #215
	bne  label_asm_395_afterif
	inc  p8v_n_funcvar
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_cv
	stz  p8v_cv+1
	lda  p8v_n_funcno
	sta  p8b_runlang.p8v_varname
	lda  #1
	sta  p8b_runlang.p8v_varname+1
	lda  #<p8b_runlang.p8v_varname
	ldy  #>p8b_runlang.p8v_varname
	sta  p8b_jdlocal.p8s_insert.p8v_name
	sty  p8b_jdlocal.p8s_insert.p8v_name+1
	lda  p8v_cv
	ldy  p8v_cv+1
	sta  p8b_jdlocal.p8s_insert.p8v_value
	sty  p8b_jdlocal.p8s_insert.p8v_value+1
	jsr  p8b_jdlocal.p8s_insert
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_395_afterif
label_asm_389_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	pha
	lda  #<p8v_auto_heap_value_25
	ldy  #>p8v_auto_heap_value_25
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_396_afterif
	lda  #1
	sta  p8v_lende
label_asm_396_afterif
	lda  p8v_lende
	beq  p8l_label_93_untilloop
	lda  (p8b_main.p8v_pcode)
	cmp  #38
	bne  label_asm_397_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_397_afterif
	lda  p8v_n_funcno
	sta  p8b_runlang.p8v_funcno
	
	lda  p8v_n_funcvar
	sta  p8b_runlang.p8v_funcvar
	
	lda  p8v_n_funcit
	sta  p8b_runlang.p8v_funcit
	
	ldy  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	jsr  p8b_funcstack.p8s_push
	lda  p8b_runlang.p8v_funcno
	jsr  p8b_jdfunc.p8s_get_value
	sta  p8v_toaddr
	sty  p8v_toaddr+1
	clc
	adc  #4
	sta  p8v_toaddr
	bcc  +
	inc  p8v_toaddr+1
+
	lda  (p8v_toaddr)
	pha
	ldy  #1
	lda  (p8v_toaddr),y
	tay
	pla
	sta  p8v_cv
	sty  p8v_cv+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
p8l_label_97_repeat
	lda  (p8b_main.p8v_pcode)
	sta  p8v_token
	cmp  #127
	beq  p8l_label_94_after
	lda  p8v_token
	cmp  #43
	bne  label_asm_398_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_expr
	sta  p8v_cv
	sty  p8v_cv+1
	bra  p8l_label_95_after
label_asm_398_afterif
	lda  p8v_token
	cmp  #2
	bne  label_asm_399_afterif
	stz  p8v_cv
	stz  p8v_cv+1
	bra  p8l_label_96_after
label_asm_399_afterif
	lda  p8v_token
	jsr  p8b_main.p8s_statement
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	bra  p8l_label_97_repeat
p8l_label_96_after
p8l_label_95_after
p8l_label_94_after
	jsr  p8b_runlang.p8s_do_endfunc
	ldy  p8v_cv+1
	lda  p8v_cv
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables
p8v_auto_heap_value_23	.byte  $2c, $2e, $30, $34, $44, $47, $ae, $b0, $b4, $c4
p8v_auto_heap_value_24	.byte  $34, $b4
p8v_auto_heap_value_25	.byte  $19, $26, $7f
	.pend

p8s_do_func	.proc
p8v_m 	= 117 	; zp UBYTE
p8v_l 	= 118 	; zp UBYTE
p8v_efueaddr 	= 119 	; zp UWORD
; statements
	stz  p8v_efueaddr
	stz  p8v_efueaddr+1
	stz  p8v_l
	stz  p8v_m
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_efueaddr
	sty  p8v_efueaddr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_endfunc	.proc
p8v_toaddr 	= 219 	; zp UWORD
p8v_n_t 	= 221 	; zp UBYTE
p8v_n_i 	= 222 	; zp UBYTE
p8v_cv 	= 223 	; zp UWORD
; statements
	stz  p8v_toaddr
	stz  p8v_toaddr+1
	stz  p8v_cv
	stz  p8v_cv+1
	stz  p8v_n_t
	stz  p8v_n_i
	jsr  p8b_funcstack.p8s_pop
	sta  p8v_toaddr
	sty  p8v_toaddr+1
	jsr  p8b_callstack_b.p8s_pop
	sta  p8b_runlang.p8v_funcno
	jsr  p8b_callstack_b.p8s_pop
	sta  p8b_runlang.p8v_funcvar
	sta  p8v_n_i
	
	lda  #1
	cmp  p8v_n_i
	beq  +
	bcs  label_asm_401_for_end
+
	sta  label_asm_402_for_modified+1
label_asm_400_for_loop
	lda  p8b_runlang.p8v_funcno
	sta  p8b_runlang.p8v_varname
	lda  p8v_n_i
	sta  p8b_runlang.p8v_varname+1
	ldy  #>p8b_runlang.p8v_varname
	lda  #<p8b_runlang.p8v_varname
	jsr  p8b_jdlocal.p8s_get_indexbyname
	sta  p8v_n_t
	jsr  p8b_callstack_w.p8s_pop
	sta  p8v_cv
	sty  p8v_cv+1
	lda  p8v_n_t
	sta  p8b_jdlocal.p8s_set_value.p8v_index
	
	lda  p8v_cv
	ldy  p8v_cv+1
	sta  p8b_jdlocal.p8s_set_value.p8v_value
	sty  p8b_jdlocal.p8s_set_value.p8v_value+1
	jsr  p8b_jdlocal.p8s_set_value
	lda  p8v_n_i
label_asm_402_for_modified          cmp  #0         ; modified 
	beq  label_asm_401_for_end
	dec  p8v_n_i
	bra  label_asm_400_for_loop
label_asm_401_for_end
	lda  p8v_toaddr
	ldy  p8v_toaddr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_if	.proc
p8v_thenaddr 	= 103 	; zp UWORD
p8v_m 	= 105 	; zp UBYTE
p8v_l 	= 106 	; zp UBYTE
p8v_endifaddr 	= 107 	; zp UWORD
p8v_elseaddr 	= 109 	; zp UWORD
p8v_b1 	= 111 	; zp BOOL
; statements
	stz  p8v_elseaddr
	stz  p8v_elseaddr+1
	stz  p8v_thenaddr
	stz  p8v_thenaddr+1
	stz  p8v_endifaddr
	stz  p8v_endifaddr+1
	stz  p8v_l
	stz  p8v_m
	lda  #1
	sta  p8v_b1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_elseaddr
	sty  p8v_elseaddr+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_thenaddr
	sty  p8v_thenaddr+1
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_l
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_endifaddr
	sty  p8v_endifaddr+1
	lda  p8v_elseaddr
	ldy  p8v_elseaddr+1
	sta  p8b_ifstack.p8s_push.p8v_elseaddress
	sty  p8b_ifstack.p8s_push.p8v_elseaddress+1
	lda  p8v_thenaddr
	ldy  p8v_thenaddr+1
	sta  p8b_ifstack.p8s_push.p8v_thenaddress
	sty  p8b_ifstack.p8s_push.p8v_thenaddress+1
	lda  p8v_endifaddr
	ldy  p8v_endifaddr+1
	sta  p8b_ifstack.p8s_push.p8v_endifaddress
	sty  p8b_ifstack.p8s_push.p8v_endifaddress+1
	jsr  p8b_ifstack.p8s_push
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_relation
	sta  p8v_b1
	lda  p8v_b1
	beq  label_asm_405_else
	lda  p8v_thenaddr
	ldy  p8v_thenaddr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	bra  label_asm_404_afterif
label_asm_405_else
	lda  p8v_elseaddr
	ora  p8v_elseaddr+1
	bne  label_asm_407_else
	lda  p8v_endifaddr
	ldy  p8v_endifaddr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	bra  label_asm_406_afterif
label_asm_407_else
	lda  p8v_elseaddr
	ldy  p8v_elseaddr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
label_asm_406_afterif
label_asm_404_afterif
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_then	.proc
p8v_r 	= 58 	; zp UBYTE
; statements
	stz  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_else	.proc
p8v_endifaddr 	= 225 	; zp UWORD
; statements
	jsr  p8b_ifstack.p8s_pope
	sta  p8v_endifaddr
	sty  p8v_endifaddr+1
	sta  p8b_main.p8v_pcode
	sty  p8b_main.p8v_pcode+1
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_do_array	.proc
p8v_vartype 	= 239 	; zp UBYTE
p8v_value 	= 240 	; zp UWORD
p8v_t 	= 242 	; zp UWORD
p8v_r 	= 244 	; zp UBYTE
p8v_n 	= 245 	; zp UBYTE
p8v_j 	= 246 	; zp UWORD
p8v_ind 	= 248 	; zp UWORD
p8v_i 	= 250 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  p8v_vartype
; statements
	stz  p8v_r
	stz  p8v_i
	stz  p8v_n
	stz  p8v_ind
	stz  p8v_ind+1
	stz  p8v_value
	stz  p8v_value+1
	stz  p8v_t
	stz  p8v_t+1
	stz  p8v_j
	stz  p8v_j+1
	jsr  p8b_main.p8s_next
	sta  p8v_i
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #36
	bne  label_asm_409_else
	jsr  p8b_main.p8s_next
	sta  p8v_r
	lda  (p8b_main.p8v_pcode)
	cmp  #41
	bne  label_asm_410_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	lda  (p8b_main.p8v_pcode)
	cmp  #35
	bne  label_asm_411_afterif
	lda  p8v_i
	jsr  p8b_jdheap.p8s_init_list
	sta  p8v_value
	sty  p8v_value+1
	lda  p8v_i
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	lda  p8v_value+1
	sta  p8b_jdarrvars.p8v_arrvars_addr+1,y
p8l_label_98_untilloop
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_get_number
	sta  p8v_value
	sty  p8v_value+1
	jsr  p8b_jdheap.p8s_add_list
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	pha
	lda  #<p8v_auto_heap_value_26
	ldy  #>p8v_auto_heap_value_26
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #3
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  p8l_label_98_untilloop
	lda  (p8b_main.p8v_pcode)
	cmp  #36
	bne  label_asm_412_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	cmp  #31
	bne  label_asm_415_else
  lda  #1
	bra  label_asm_414_afterif
label_asm_415_else
  lda  #0
label_asm_414_afterif
	beq  label_asm_413_shortcut
	lda  p8b_jdheap.p8v_ll
	cmp  #<1
	bne  label_asm_417_else
	lda  p8b_jdheap.p8v_ll+1
	cmp  #>1
	bne  label_asm_417_else
  lda  #1
	bra  label_asm_416_afterif
label_asm_417_else
  lda  #0
label_asm_416_afterif
label_asm_413_shortcut
	beq  label_asm_419_else
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	lda  (p8b_main.p8v_pcode)
	cmp  #44
	bne  label_asm_420_afterif
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
	jsr  p8b_apu.p8s_get_number
	sta  p8v_t
	sty  p8v_t+1
	lda  #<1
	ldy  #>1
	sta  p8v_j
	sty  p8v_j+1
	
	ldy  p8v_t+1
	lda  p8v_t
	cpy  p8v_j+1
	                bcc  label_asm_422_for_end
	                bne  +
	                cmp  p8v_j
	                bcc  label_asm_422_for_end
+
	sty  label_asm_423_for_modified+1
	sta  label_asm_424_for_modifiedb+1
label_asm_421_for_loop
	ldy  p8v_value+1
	lda  p8v_value
	jsr  p8b_jdheap.p8s_add_list
	lda  p8v_j+1
label_asm_423_for_modified  cmp  #0    ; modified 
	bne  +
	lda  p8v_j
label_asm_424_for_modifiedb cmp  #0    ; modified 
	beq  label_asm_422_for_end
+               inc  p8v_j
	bne  label_asm_421_for_loop
	inc  p8v_j+1
	bra  label_asm_421_for_loop
label_asm_422_for_end
label_asm_420_afterif
	bra  label_asm_418_afterif
label_asm_419_else
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
label_asm_418_afterif
	jsr  p8b_jdheap.p8s_close_list
label_asm_412_afterif
label_asm_411_afterif
label_asm_410_afterif
	bra  label_asm_408_afterif
label_asm_409_else
	jsr  p8b_apu.p8s_expr
	sta  p8v_ind
	sty  p8v_ind+1
	jsr  p8b_main.p8s_next
	sta  p8v_r
	lda  (p8b_main.p8v_pcode)
	cmp  #41
	bne  label_asm_425_afterif
	jsr  p8b_main.p8s_next
	sta  p8v_r
	jsr  p8b_apu.p8s_expr
	sta  p8v_value
	sty  p8v_value+1
	lda  p8v_vartype
	cmp  #1
	bne  label_asm_426_afterif
	lda  p8b_runlang.p8v_funcno
	sta  p8b_runlang.p8v_varname
	lda  p8v_i
	sta  p8b_runlang.p8v_varname+1
	ldy  #>p8b_runlang.p8v_varname
	lda  #<p8b_runlang.p8v_varname
	jsr  p8b_jdlocal.p8s_get_name
	sta  p8v_n
	sta  p8v_i
	
label_asm_426_afterif
	lda  p8v_i
	sta  p8b_jdarrvars.p8s_set_value.p8v_nr
	
	lda  p8v_ind
	ldy  p8v_ind+1
	sta  p8b_jdarrvars.p8s_set_value.p8v_index
	sty  p8b_jdarrvars.p8s_set_value.p8v_index+1
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdarrvars.p8s_set_value.p8v_value
	sty  p8b_jdarrvars.p8s_set_value.p8v_value+1
	jsr  p8b_jdarrvars.p8s_set_value
	inc  p8b_main.p8v_pcode
	bne  +
	inc  p8b_main.p8v_pcode+1
+
label_asm_425_afterif
label_asm_408_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables
p8v_auto_heap_value_26	.byte  $00, $19, $24
	.pend

p8s_do_let	.proc
p8v_vartype 	= 64 	; zp UBYTE
p8v_value 	= 98 	; zp UWORD
p8v_r 	= 100 	; zp UBYTE
p8v_mt 	= 101 	; zp UBYTE
p8v_i 	= 102 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  p8v_vartype
; statements
	stz  p8v_r
	stz  p8v_i
	lda  (p8b_main.p8v_pcode)
	sta  p8v_mt
	stz  p8v_value
	stz  p8v_value+1
	jsr  p8b_main.p8s_next
	sta  p8v_i
	jsr  p8b_main.p8s_next
	sta  p8v_r
	ldy  #>prog8_interned_strings.string_94
	lda  #<prog8_interned_strings.string_94
	jsr  txt.print
	lda  p8v_mt
	sec
	jsr  txt.print_ubhex
	ldy  #>prog8_interned_strings.string_95
	lda  #<prog8_interned_strings.string_95
	jsr  txt.print
	lda  p8v_i
	sec
	jsr  txt.print_ubhex
	lda  p8v_r
	cmp  #41
	bne  label_asm_428_else
	jsr  p8b_main.p8s_next
	ldy  #0
	lda  p8v_vartype
	jsr  p8b_varstack.p8s_push
	ldy  #0
	lda  p8v_i
	jsr  p8b_varstack.p8s_push
	lda  (p8b_main.p8v_pcode)
	cmp  #71
	bne  label_asm_430_else
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  txt.print
	jsr  p8b_apu.p8s_expr_l
	sta  p8v_value
	sty  p8v_value+1
	bra  label_asm_429_afterif
label_asm_430_else
	lda  p8v_vartype
	cmp  #2
	bne  label_asm_432_else
	ldy  #>prog8_interned_strings.string_97
	lda  #<prog8_interned_strings.string_97
	jsr  txt.print
	jsr  p8b_apu.p8s_expr_str
	sta  p8v_value
	sty  p8v_value+1
	bra  label_asm_431_afterif
label_asm_432_else
	ldy  #>prog8_interned_strings.string_98
	lda  #<prog8_interned_strings.string_98
	jsr  txt.print
	jsr  p8b_apu.p8s_expr
	sta  p8v_value
	sty  p8v_value+1
label_asm_431_afterif
label_asm_429_afterif
	ldy  #>prog8_interned_strings.string_99
	lda  #<prog8_interned_strings.string_99
	jsr  txt.print
	ldy  p8v_value+1
	lda  p8v_value
	sec
	jsr  txt.print_uwhex
	jsr  p8b_varstack.p8s_pop
	sta  p8v_i
	jsr  p8b_varstack.p8s_pop
	sta  p8v_vartype
	ldy  #>prog8_interned_strings.string_100
	lda  #<prog8_interned_strings.string_100
	jsr  txt.print
	lda  p8v_mt
	sec
	jsr  txt.print_ubhex
	ldy  #>prog8_interned_strings.string_101
	lda  #<prog8_interned_strings.string_101
	jsr  txt.print
	lda  p8v_i
	sec
	jsr  txt.print_ubhex
	lda  #13
	jsr  txt.chrout
	lda  p8v_vartype
	cmp  #1
	bne  label_asm_434_else
	lda  p8v_mt
	cmp  #174
	bne  label_asm_436_else
	lda  p8v_i
	sta  p8b_jdlocal.p8s_set_value.p8v_index
	
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdlocal.p8s_set_value.p8v_value
	sty  p8b_jdlocal.p8s_set_value.p8v_value+1
	jsr  p8b_jdlocal.p8s_set_value
	bra  label_asm_435_afterif
label_asm_436_else
	lda  p8v_value
	pha
	lda  p8v_i
	sta  P8ZP_SCRATCH_W2
	stz  P8ZP_SCRATCH_W2+1
	pla
	sta  (P8ZP_SCRATCH_W2)
label_asm_435_afterif
	bra  label_asm_433_afterif
label_asm_434_else
	lda  p8v_vartype
	bne  label_asm_438_else
	lda  p8v_mt
	pha
	lda  #<p8v_auto_heap_value_27
	ldy  #>p8v_auto_heap_value_27
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	pla
	ldy  #2
	jsr  prog8_lib.containment_bytearray
	cmp  #0
	beq  label_asm_440_else
	lda  p8v_i
	sta  p8b_jdlocal.p8s_set_value.p8v_index
	
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdlocal.p8s_set_value.p8v_value
	sty  p8b_jdlocal.p8s_set_value.p8v_value+1
	jsr  p8b_jdlocal.p8s_set_value
	bra  label_asm_439_afterif
label_asm_440_else
	lda  p8v_i
	sta  p8b_jdvars.p8s_set_value.p8v_index
	
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdvars.p8s_set_value.p8v_value
	sty  p8b_jdvars.p8s_set_value.p8v_value+1
	jsr  p8b_jdvars.p8s_set_value
label_asm_439_afterif
	bra  label_asm_437_afterif
label_asm_438_else
	lda  p8v_vartype
	cmp  #2
	bne  label_asm_441_afterif
	lda  p8v_i
	sta  p8b_jdstrvars.p8s_set_value.p8v_index
	
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdstrvars.p8s_set_value.p8v_value
	sty  p8b_jdstrvars.p8s_set_value.p8v_value+1
	jsr  p8b_jdstrvars.p8s_set_value
label_asm_441_afterif
label_asm_437_afterif
label_asm_433_afterif
	bra  label_asm_427_afterif
label_asm_428_else
	lda  #1
	jsr  p8b_error.p8s_set
label_asm_427_afterif
	lda  p8b_main.p8v_pcode
	bne  +
	dec  p8b_main.p8v_pcode+1
+                           dec  p8b_main.p8v_pcode
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables
p8v_auto_heap_value_27	.byte  $b0, $c4
	.pend
prog8_init_vars	.block
	stz  p8b_runlang.p8v_funcno
	stz  p8b_runlang.p8v_funcvar
	stz  p8b_runlang.p8v_funcit
	rts
	.bend
	.pend

; ---- block: 'p8b_error' ----
p8b_error	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_number	.byte  ?
p8v_state	.byte  ?
	.send BSS


p8s_clear	.proc
; statements
	stz  p8b_error.p8v_number
	stz  p8b_error.p8v_state
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_set	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_rnumber
; statements
	sta  p8b_error.p8v_number
	
	lda  #1
	sta  p8b_error.p8v_state
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_rnumber	.byte  ?
	.send BSS
	.pend

p8s_print	.proc
; statements
	lda  p8b_error.p8v_number
	asl  a
	tay
	lda  p8b_errtext.p8v_txttable,y
	ldx  p8b_errtext.p8v_txttable+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	jsr  txt.print
	ldy  #>prog8_interned_strings.string_102
	lda  #<prog8_interned_strings.string_102
	jsr  txt.print
	ldy  p8b_main.p8v_linenr+1
	lda  p8b_main.p8v_linenr
	jsr  txt.print_uw
	lda  #13
	jmp  txt.chrout
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_errtext' ----
p8b_errtext	.proc

; non-zeropage variables
p8v_txttable	.word  prog8_interned_strings.string_103, prog8_interned_strings.string_104, prog8_interned_strings.string_105, prog8_interned_strings.string_106, prog8_interned_strings.string_107, prog8_interned_strings.string_108, prog8_interned_strings.string_109

	.pend

; ---- block: 'p8b_rundos' ----
p8b_rundos	.proc



p8s_do_load	.proc
p8v_sbank 	= 251 	; zp UBYTE
p8v_r 	= 252 	; zp UBYTE
p8v_fname_len 	= 253 	; zp UBYTE
p8v_flag 	= 254 	; zp BOOL
p8v_end_bank 	= 255 	; zp UBYTE
; statements
	stz  p8v_r
	stz  p8v_fname_len
	stz  p8v_end_bank
	stz  p8v_end_address
	stz  p8v_end_address+1
	stz  p8v_sbank
	stz  p8v_flag
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #45
	bne  label_asm_442_afterif
	ldy  #>p8b_main.p8v_filename
	lda  #<p8b_main.p8v_filename
	jsr  p8b_main.p8s_get_string
label_asm_442_afterif
	ldy  #>p8b_main.p8v_filename
	lda  #<p8b_main.p8v_filename
	jsr  string.length
	sty  p8v_fname_len
	lda  p8v_fname_len
	beq  label_asm_444_else
	ldy  #2
	ldx  #8
	lda  #1
	jsr  cbm.SETLFS
	ldy  #>p8b_main.p8v_filename
	ldx  #<p8b_main.p8v_filename
	lda  p8v_fname_len
	jsr  cbm.SETNAM
	; inlined routine follows: getrambank
        lda  $00
	; inlined routine end: getrambank
	sta  p8v_sbank
	lda  #2
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	ldy  #>$a000
	ldx  #<$a000
	lda  #0
	jsr  cbm.LOAD
	sta  p8v_end_bank
	stx  p8v_end_address
	sty  p8v_end_address+1
	lda  #0
	rol  a
	sta  p8v_flag
	lda  p8v_flag
	beq  label_asm_446_else
	lda  #3
	jsr  p8b_error.p8s_set
	bra  label_asm_445_afterif
label_asm_446_else
	lda  #$7f
	ldy  p8v_end_address
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_end_address+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  #0
	pha
	lda  p8v_end_address
	ldy  p8v_end_address+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	pla
	sta  (P8ZP_SCRATCH_W2),y
	ldy  #>prog8_interned_strings.string_110
	lda  #<prog8_interned_strings.string_110
	jsr  txt.print
	ldy  p8v_end_address+1
	lda  p8v_end_address
	sec
	jsr  txt.print_uwhex
	ldy  #>prog8_interned_strings.string_111
	lda  #<prog8_interned_strings.string_111
	jsr  txt.print
	; inlined routine follows: getrambank
        lda  $00
	; inlined routine end: getrambank
	clc
	adc  p8v_end_bank
	jsr  txt.print_ub
	lda  #13
	jsr  txt.chrout
label_asm_445_afterif
	lda  p8v_sbank
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	lda  #0
	rts
label_asm_444_else
	lda  #1
	rts
label_asm_443_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_end_address	.word  ?
	.send BSS
	.pend

p8s_do_list	.proc
; statements
	stz  p8v_sbank
	stz  p8v_lende
	; inlined routine follows: getrambank
        lda  $00
	; inlined routine end: getrambank
	sta  p8v_sbank
	lda  #2
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	lda  #<$a000
	ldy  #>$a000
	sta  p8v_lptr
	sty  p8v_lptr+1
	
p8l_label_99_untilloop
	lda  p8v_lptr
	ldy  p8v_lptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #10
	bne  label_asm_448_else
	lda  #13
	jsr  txt.chrout
	bra  label_asm_447_afterif
label_asm_448_else
	lda  p8v_lptr
	ldy  p8v_lptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	jsr  txt.chrout
label_asm_447_afterif
	inc  p8v_lptr
	bne  +
	inc  p8v_lptr+1
+
	lda  p8v_lptr
	ldy  p8v_lptr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	cmp  #127
	bne  label_asm_451_else
  lda  #1
	bra  label_asm_450_afterif
label_asm_451_else
  lda  #0
label_asm_450_afterif
	beq  label_asm_449_shortcut
	lda  p8v_lptr
	ldy  p8v_lptr+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	lda  (P8ZP_SCRATCH_W2),y
	beq  +
	lda  #1
+                           eor  #1
label_asm_449_shortcut
	beq  label_asm_452_afterif
	lda  #1
	sta  p8v_lende
label_asm_452_afterif
	lda  p8v_lende
	beq  p8l_label_99_untilloop
	lda  p8v_sbank
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	lda  #13
	jsr  txt.chrout
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_lende	.byte  ?
p8v_lptr	.word  ?
p8v_sbank	.byte  ?
	.send BSS
	.pend

p8s_do_dir	.proc
; statements
	stz  p8v_num_files
	stz  p8v_r
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #45
	bne  label_asm_454_else
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  p8b_main.p8s_get_string
	bra  label_asm_453_afterif
label_asm_454_else
	lda  #<prog8_interned_strings.string_112
	ldy  #>prog8_interned_strings.string_112
	sta  cx16.r0
	sty  cx16.r0+1
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  sys.internal_stringcopy
label_asm_453_afterif
	ldy  #>p8b_main.p8v_buffer
	lda  #<p8b_main.p8v_buffer
	jsr  diskio.lf_start_list
	cmp  #0
	beq  label_asm_455_afterif
	ldy  #>prog8_interned_strings.string_113
	lda  #<prog8_interned_strings.string_113
	jsr  txt.print
p8l_label_101_whileloop
	jsr  diskio.lf_next_entry
	cmp  #0
	beq  p8l_label_102_afterwhile
	inc  p8v_num_files
	lda  #$20
	jsr  txt.chrout
	lda  #$20
	jsr  txt.chrout
	lda  #<prog8_interned_strings.string_84
	ldy  #>prog8_interned_strings.string_84
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #>diskio.list_filetype
	lda  #<diskio.list_filetype
	jsr  prog8_lib.strcmp_mem
	cmp  #0
	bne  label_asm_457_else
	ldy  #>prog8_interned_strings.string_114
	lda  #<prog8_interned_strings.string_114
	jsr  txt.print
	bra  label_asm_456_afterif
label_asm_457_else
	ldy  diskio.list_blocks+1
	lda  diskio.list_blocks
	jsr  txt.print_uw
label_asm_456_afterif
	lda  #9
	jsr  txt.column
	ldy  #>diskio.list_filename
	lda  #<diskio.list_filename
	jsr  txt.print
	lda  #13
	jsr  txt.chrout
	jsr  cbm.STOP
	bne  label_asm_458_branch_else
	ldy  #>prog8_interned_strings.string_115
	lda  #<prog8_interned_strings.string_115
	jsr  txt.print
	bra  p8l_label_100_after
label_asm_458_branch_else
	bra  p8l_label_101_whileloop
p8l_label_102_afterwhile
p8l_label_100_after
	jsr  diskio.lf_end_list
	lda  p8v_num_files
	bne  label_asm_459_afterif
	ldy  #>prog8_interned_strings.string_116
	lda  #<prog8_interned_strings.string_116
	jsr  txt.print
label_asm_459_afterif
	lda  #1
	rts
label_asm_455_afterif
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_num_files	.byte  ?
p8v_r	.byte  ?
	.send BSS
	.pend

p8s_do_edit	.proc
; statements
	stz  p8v_r
	stz  p8v_fname_len
	jsr  p8b_main.p8s_next
	sta  p8v_r
	cmp  #45
	bne  label_asm_461_else
	ldy  #>p8b_main.p8v_filename
	lda  #<p8b_main.p8v_filename
	jsr  p8b_main.p8s_get_string
	ldy  #>p8b_main.p8v_filename
	lda  #<p8b_main.p8v_filename
	jsr  string.length
	sty  p8v_fname_len
	bra  label_asm_460_afterif
label_asm_461_else
	ldy  #>p8b_main.p8v_filename
	lda  #<p8b_main.p8v_filename
	jsr  string.length
	sty  p8v_fname_len
label_asm_460_afterif
	jsr  cx16.search_x16edit
	sta  p8v_x16edit_bank
	cmp  #255
	bcs  label_asm_463_else
	; inlined routine follows: getrombank
        lda  $01
	; inlined routine end: getrombank
	sta  p8v_sbank
	lda  p8v_x16edit_bank
	; inlined routine follows: rombank
        sta  $01
	; inlined routine end: rombank
	lda  #<p8b_main.p8v_filename
	ldy  #>p8b_main.p8v_filename
	sta  cx16.r0
	sty  cx16.r0+1
	lda  p8v_fname_len
	sta  cx16.r1
	lda  #0
	sta  cx16.r1+1
	
	ldy  #$fe
	ldx  #2
	jsr  cx16.x16edit_loadfile
	lda  p8v_sbank
	; inlined routine follows: rombank
        sta  $01
	; inlined routine end: rombank
	lda  #1
	rts
label_asm_463_else
	ldy  #>prog8_interned_strings.string_117
	lda  #<prog8_interned_strings.string_117
	jsr  txt.print
	lda  #0
	rts
label_asm_462_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_fname_len	.byte  ?
p8v_r	.byte  ?
p8v_sbank	.byte  ?
p8v_x16edit_bank	.byte  ?
	.send BSS
	.pend
	.pend

; ---- block: 'p8b_jdstr' ----
p8b_jdstr	.proc
	p8c_vbank = $60

; non-zeropage variables without initialization value
	.section BSS
p8v_lini	.word  ?
p8v_r	.word  ?
p8v_sbank	.byte  ?
p8v_start	.word  ?
	.send BSS


p8s_add	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_name
	sty  p8v_name+1
; statements
	; inlined routine follows: getrambank
        lda  $00
	; inlined routine end: getrambank
	sta  p8b_jdstr.p8v_sbank
	lda  #$60
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	ldy  p8v_name+1
	lda  p8v_name
	jsr  string.length
	tya
	clc
	adc  #1
	sta  p8b_jdstr.p8v_lini
	stz  p8b_jdstr.p8v_lini+1
	ldy  #>$11
	lda  #<$11
	cmp  p8b_jdstr.p8v_lini
	tya
	sbc  p8b_jdstr.p8v_lini+1
	bcs  label_asm_464_afterif
	lda  #<$11
	ldy  #>$11
	sta  p8b_jdstr.p8v_lini
	sty  p8b_jdstr.p8v_lini+1
	
label_asm_464_afterif
	lda  p8b_jdstr.p8v_start
	ldy  p8b_jdstr.p8v_start+1
	sta  p8b_jdstr.p8v_r
	sty  p8b_jdstr.p8v_r+1
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	lda  p8b_jdstr.p8v_r
	sta  cx16.r1
	lda  p8b_jdstr.p8v_r+1
	sta  cx16.r1+1
	
	ldy  p8b_jdstr.p8v_lini+1
	lda  p8b_jdstr.p8v_lini
	jsr  sys.memcopy
	lda  p8b_jdstr.p8v_start
	clc
	adc  p8b_jdstr.p8v_lini
	sta  p8b_jdstr.p8v_start
	lda  p8b_jdstr.p8v_start+1
	adc  p8b_jdstr.p8v_lini+1
	sta  p8b_jdstr.p8v_start+1
	lda  p8b_jdstr.p8v_sbank
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	ldy  p8b_jdstr.p8v_r+1
	lda  p8b_jdstr.p8v_r
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_name	.word  ?
	.send BSS
	.pend

p8s_get	.proc
; statements
	stz  p8v_lp
	stz  p8v_lp+1
	; inlined routine follows: getrambank
        lda  $00
	; inlined routine end: getrambank
	sta  p8b_jdstr.p8v_sbank
	lda  #$60
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	lda  p8v_prt
	ora  p8v_prt+1
	bne  label_asm_466_else
	lda  #0
	ldy  p8v_buf
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_buf+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	bra  label_asm_465_afterif
label_asm_466_else
	lda  p8v_buf
	ldy  p8v_buf+1
	sta  p8v_lp
	sty  p8v_lp+1
p8l_label_103_untilloop
	lda  p8v_prt
	ldy  p8v_prt+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_lp
	bne  +
	inc  p8v_lp+1
+
	inc  p8v_prt
	bne  +
	inc  p8v_prt+1
+
	lda  p8v_prt
	ldy  p8v_prt+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	bne  p8l_label_103_untilloop
	lda  #0
	ldy  p8v_lp
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_lp+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
label_asm_465_afterif
	lda  p8b_jdstr.p8v_sbank
	; inlined routine follows: rambank
        sta  $00
	; inlined routine end: rambank
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_buf	.word  ?
p8v_lp	.word  ?
p8v_prt	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	lda  #<$a000
	ldy  #>$a000
	sta  p8b_jdstr.p8v_start
	sty  p8b_jdstr.p8v_start+1
	
	rts
	.bend
	.pend

; ---- block: 'p8b_jdheap' ----
p8b_jdheap	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_lini	.byte  ?
p8v_ll	.word  ?
p8v_ml	.word  ?
p8v_r	.word  ?
p8v_start	.word  ?
	.send BSS


p8s_init_list	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_nr
; statements
	stz  p8b_jdheap.p8v_ll
	stz  p8b_jdheap.p8v_ll+1
	ldy  p8b_jdheap.p8v_start+1
	lda  p8b_jdheap.p8v_start
	sec
	sbc  #<3
	tax
	tya
	sbc  #>3
	tay
	txa
	sta  p8b_jdheap.p8v_r
	sty  p8b_jdheap.p8v_r+1
	lda  p8v_nr
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_jdheap.p8v_r
	bne  +
	inc  p8b_jdheap.p8v_r+1
+
	lda  p8b_jdheap.p8v_r
	ldy  p8b_jdheap.p8v_r+1
	sta  p8b_jdheap.p8v_ml
	sty  p8b_jdheap.p8v_ml+1
	lda  #0
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_jdheap.p8v_r
	bne  +
	inc  p8b_jdheap.p8v_r+1
+
	lda  #0
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  p8b_jdheap.p8v_start
	sec
	sbc  #4
	sta  p8b_jdheap.p8v_start
	bcs  +
	dec  p8b_jdheap.p8v_start+1
+
	ldy  p8b_jdheap.p8v_start+1
	lda  p8b_jdheap.p8v_start
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_nr	.byte  ?
	.send BSS
	.pend

p8s_add_list	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_value
	sty  p8v_value+1
; statements
	inc  p8b_jdheap.p8v_ll
	bne  +
	inc  p8b_jdheap.p8v_ll+1
+
	ldy  p8b_jdheap.p8v_start+1
	lda  p8b_jdheap.p8v_start
	sec
	sbc  #<2
	tax
	tya
	sbc  #>2
	tay
	txa
	sta  p8b_jdheap.p8v_r
	sty  p8b_jdheap.p8v_r+1
	inc  p8b_jdheap.p8v_r
	bne  +
	inc  p8b_jdheap.p8v_r+1
+
	lda  p8v_value
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_jdheap.p8v_r
	bne  +
	inc  p8b_jdheap.p8v_r+1
+
	lda  p8v_value+1
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  p8b_jdheap.p8v_start
	sec
	sbc  #2
	sta  p8b_jdheap.p8v_start
	bcs  +
	dec  p8b_jdheap.p8v_start+1
+
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_value	.word  ?
	.send BSS
	.pend

p8s_close_list	.proc
; statements
	lda  p8b_jdheap.p8v_ll
	ldy  p8b_jdheap.p8v_ml
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_ml+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	lda  p8b_jdheap.p8v_ll+1
	pha
	lda  p8b_jdheap.p8v_ml
	ldy  p8b_jdheap.p8v_ml+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #1
	pla
	sta  (P8ZP_SCRATCH_W2),y
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_add_str	.proc
; statements
	ldy  p8v_value+1
	lda  p8v_value
	jsr  string.length
	tya
	clc
	adc  #1
	sta  p8b_jdheap.p8v_lini
	clc
	adc  #2
	sta  P8ZP_SCRATCH_W1
	stz  P8ZP_SCRATCH_W1+1
	ldy  p8b_jdheap.p8v_start+1
	lda  p8b_jdheap.p8v_start
	sec
	sbc  P8ZP_SCRATCH_W1
	tax
	tya
	sbc  P8ZP_SCRATCH_W1+1
	tay
	txa
	sta  p8b_jdheap.p8v_r
	sty  p8b_jdheap.p8v_r+1
	sta  p8b_jdheap.p8v_ml
	sty  p8b_jdheap.p8v_ml+1
	lda  p8v_nr
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_jdheap.p8v_r
	bne  +
	inc  p8b_jdheap.p8v_r+1
+
	lda  p8b_jdheap.p8v_lini
	ldy  p8b_jdheap.p8v_r
	sty  P8ZP_SCRATCH_W2
	ldy  p8b_jdheap.p8v_r+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8b_jdheap.p8v_r
	bne  +
	inc  p8b_jdheap.p8v_r+1
+
	lda  p8v_value
	sta  cx16.r0
	lda  p8v_value+1
	sta  cx16.r0+1
	
	lda  p8b_jdheap.p8v_r
	sta  cx16.r1
	lda  p8b_jdheap.p8v_r+1
	sta  cx16.r1+1
	
	ldy  #0
	lda  p8b_jdheap.p8v_lini
	jsr  sys.memcopy
	lda  p8b_jdheap.p8v_lini
	clc
	adc  #2
	sta  P8ZP_SCRATCH_B1
	lda  p8b_jdheap.p8v_start
	sec
	sbc  P8ZP_SCRATCH_B1
	sta  p8b_jdheap.p8v_start
	bcs  +
	dec  p8b_jdheap.p8v_start+1
+
	ldy  p8b_jdheap.p8v_ml+1
	lda  p8b_jdheap.p8v_ml
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_nr	.byte  ?
p8v_value	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	lda  #<$9e00
	ldy  #>$9e00
	sta  p8b_jdheap.p8v_start
	sty  p8b_jdheap.p8v_start+1
	
	rts
	.bend
	.pend

; ---- block: 'p8b_jdvars' ----
p8b_jdvars	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cn	.byte  ?
p8v_numvars_name	.fill  256
p8v_numvars_next	.fill  128
p8v_numvars_value	.fill  256
p8v_r	.word  ?
	.send BSS
; non-zeropage variables
p8v_buffer	; PETSCII:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00


p8s_insert	.proc
; statements
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_467_afterif
	lda  #1
	sta  p8v_index
label_asm_467_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdvars.p8v_numvars_name,y
	ldx  p8b_jdvars.p8v_numvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_469_else
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdvars.p8v_r
	sty  p8b_jdvars.p8v_r+1
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdvars.p8v_r
	sta  p8b_jdvars.p8v_numvars_name,y
	lda  p8b_jdvars.p8v_r+1
	sta  p8b_jdvars.p8v_numvars_name+1,y
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdvars.p8v_numvars_value,y
	lda  p8v_value+1
	sta  p8b_jdvars.p8v_numvars_value+1,y
	ldx  p8v_index
	stz  p8b_jdvars.p8v_numvars_next,x
	lda  p8v_index
	rts
label_asm_469_else
	lda  p8v_index
	sta  p8v_current
	
p8l_label_105_whileloop
	ldy  p8v_current
	lda  p8b_jdvars.p8v_numvars_next,y
	beq  p8l_label_106_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdvars.p8v_numvars_name,y
	ldx  p8b_jdvars.p8v_numvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdvars.p8v_buffer
	ldy  #>p8b_jdvars.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdvars.p8v_buffer
	lda  #<p8b_jdvars.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_470_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdvars.p8v_numvars_value,y
	lda  p8v_value+1
	sta  p8b_jdvars.p8v_numvars_value+1,y
	lda  p8v_current
	rts
label_asm_470_afterif
	ldy  p8v_current
	lda  p8b_jdvars.p8v_numvars_next,y
	sta  p8v_current
	bra  p8l_label_105_whileloop
p8l_label_106_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdvars.p8v_numvars_name,y
	ldx  p8b_jdvars.p8v_numvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdvars.p8v_buffer
	ldy  #>p8b_jdvars.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdvars.p8v_buffer
	lda  #<p8b_jdvars.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_471_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdvars.p8v_numvars_value,y
	lda  p8v_value+1
	sta  p8b_jdvars.p8v_numvars_value+1,y
	lda  p8v_current
	rts
label_asm_471_afterif
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdvars.p8v_r
	sty  p8b_jdvars.p8v_r+1
p8l_label_107_untilloop
	inc  p8b_jdvars.p8v_cn
	lda  p8b_jdvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdvars.p8v_numvars_name,y
	ldx  p8b_jdvars.p8v_numvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8l_label_107_untilloop
	lda  p8b_jdvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdvars.p8v_r
	sta  p8b_jdvars.p8v_numvars_name,y
	lda  p8b_jdvars.p8v_r+1
	sta  p8b_jdvars.p8v_numvars_name+1,y
	lda  p8b_jdvars.p8v_cn
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdvars.p8v_numvars_value,y
	lda  p8v_value+1
	sta  p8b_jdvars.p8v_numvars_value+1,y
	ldx  p8b_jdvars.p8v_cn
	stz  p8b_jdvars.p8v_numvars_next,x
	ldy  p8v_current
	lda  p8b_jdvars.p8v_cn
	sta  p8b_jdvars.p8v_numvars_next,y
label_asm_468_afterif
	lda  p8b_jdvars.p8v_cn
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_value	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_index
; statements
	asl  a
	tay
	lda  p8b_jdvars.p8v_numvars_value,y
	ldx  p8b_jdvars.p8v_numvars_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
	.send BSS
	.pend

p8s_set_value	.proc
; statements
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdvars.p8v_numvars_value,y
	lda  p8v_value+1
	sta  p8b_jdvars.p8v_numvars_value+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
p8v_value	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_jdstrvars' ----
p8b_jdstrvars	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cn	.byte  ?
p8v_r	.word  ?
p8v_strvars_addr	.fill  128
p8v_strvars_name	.fill  128
p8v_strvars_next	.fill  64
	.send BSS
; non-zeropage variables
p8v_buffer	; PETSCII:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00


p8s_insert	.proc
; statements
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_472_afterif
	lda  #1
	sta  p8v_index
label_asm_472_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_strvars_name,y
	ldx  p8b_jdstrvars.p8v_strvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_474_else
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdstrvars.p8v_r
	sty  p8b_jdstrvars.p8v_r+1
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_r
	sta  p8b_jdstrvars.p8v_strvars_name,y
	lda  p8b_jdstrvars.p8v_r+1
	sta  p8b_jdstrvars.p8v_strvars_name+1,y
	lda  p8v_index
	asl  a
	tay
	lda  p8v_index
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	iny
	lda  #0
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	ldx  p8v_index
	stz  p8b_jdstrvars.p8v_strvars_next,x
	lda  p8v_index
	rts
label_asm_474_else
	lda  p8v_index
	sta  p8v_current
	
p8l_label_110_whileloop
	ldy  p8v_current
	lda  p8b_jdstrvars.p8v_strvars_next,y
	beq  p8l_label_111_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_strvars_name,y
	ldx  p8b_jdstrvars.p8v_strvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdstrvars.p8v_buffer
	ldy  #>p8b_jdstrvars.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdstrvars.p8v_buffer
	lda  #<p8b_jdstrvars.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_475_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_current
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	iny
	lda  #0
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	lda  p8v_current
	rts
label_asm_475_afterif
	ldy  p8v_current
	lda  p8b_jdstrvars.p8v_strvars_next,y
	sta  p8v_current
	bra  p8l_label_110_whileloop
p8l_label_111_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_strvars_name,y
	ldx  p8b_jdstrvars.p8v_strvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdstrvars.p8v_buffer
	ldy  #>p8b_jdstrvars.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdstrvars.p8v_buffer
	lda  #<p8b_jdstrvars.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_476_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_current
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	iny
	lda  #0
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	lda  p8v_current
	rts
label_asm_476_afterif
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdstrvars.p8v_r
	sty  p8b_jdstrvars.p8v_r+1
	lda  p8v_current
	sta  p8b_jdstrvars.p8v_cn
	
p8l_label_112_untilloop
	inc  p8b_jdstrvars.p8v_cn
	lda  p8b_jdstrvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_strvars_name,y
	ldx  p8b_jdstrvars.p8v_strvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8l_label_112_untilloop
	lda  p8b_jdstrvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_r
	sta  p8b_jdstrvars.p8v_strvars_name,y
	lda  p8b_jdstrvars.p8v_r+1
	sta  p8b_jdstrvars.p8v_strvars_name+1,y
	lda  p8b_jdstrvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_cn
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	iny
	lda  #0
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	ldx  p8b_jdstrvars.p8v_cn
	stz  p8b_jdstrvars.p8v_strvars_next,x
	ldy  p8v_current
	lda  p8b_jdstrvars.p8v_cn
	sta  p8b_jdstrvars.p8v_strvars_next,y
label_asm_473_afterif
	lda  p8b_jdstrvars.p8v_cn
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_value	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_index
; statements
	asl  a
	tay
	lda  p8b_jdstrvars.p8v_strvars_addr,y
	ldx  p8b_jdstrvars.p8v_strvars_addr+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
	.send BSS
	.pend

p8s_set_value	.proc
; statements
	stz  p8v_taddr
	stz  p8v_taddr+1
	lda  p8v_index
	sta  p8b_jdheap.p8s_add_str.p8v_nr
	
	lda  p8v_value
	ldy  p8v_value+1
	sta  p8b_jdheap.p8s_add_str.p8v_value
	sty  p8b_jdheap.p8s_add_str.p8v_value+1
	jsr  p8b_jdheap.p8s_add_str
	sta  p8v_taddr
	sty  p8v_taddr+1
	lda  p8v_index
	asl  a
	tay
	lda  p8v_taddr
	sta  p8b_jdstrvars.p8v_strvars_addr,y
	lda  p8v_taddr+1
	sta  p8b_jdstrvars.p8v_strvars_addr+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
p8v_taddr	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_jdarrvars' ----
p8b_jdarrvars	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_arrvars_addr	.fill  128
p8v_arrvars_name	.fill  128
p8v_arrvars_next	.fill  64
p8v_cn	.byte  ?
p8v_r	.word  ?
	.send BSS
; non-zeropage variables
p8v_buffer	; PETSCII:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00


p8s_insert	.proc
; statements
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_477_afterif
	lda  #1
	sta  p8v_index
label_asm_477_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_name,y
	ldx  p8b_jdarrvars.p8v_arrvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_479_else
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdarrvars.p8v_r
	sty  p8b_jdarrvars.p8v_r+1
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_r
	sta  p8b_jdarrvars.p8v_arrvars_name,y
	lda  p8b_jdarrvars.p8v_r+1
	sta  p8b_jdarrvars.p8v_arrvars_name+1,y
	lda  p8v_index
	asl  a
	tay
	lda  p8v_index
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	iny
	lda  #0
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	ldx  p8v_index
	stz  p8b_jdarrvars.p8v_arrvars_next,x
	lda  p8v_index
	rts
label_asm_479_else
	lda  p8v_index
	sta  p8v_current
	
p8l_label_115_whileloop
	ldy  p8v_current
	lda  p8b_jdarrvars.p8v_arrvars_next,y
	beq  p8l_label_116_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_name,y
	ldx  p8b_jdarrvars.p8v_arrvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdarrvars.p8v_buffer
	ldy  #>p8b_jdarrvars.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdarrvars.p8v_buffer
	lda  #<p8b_jdarrvars.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_480_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_current
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	iny
	lda  #0
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	lda  p8v_current
	rts
label_asm_480_afterif
	ldy  p8v_current
	lda  p8b_jdarrvars.p8v_arrvars_next,y
	sta  p8v_current
	bra  p8l_label_115_whileloop
p8l_label_116_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_name,y
	ldx  p8b_jdarrvars.p8v_arrvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdarrvars.p8v_buffer
	ldy  #>p8b_jdarrvars.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdarrvars.p8v_buffer
	lda  #<p8b_jdarrvars.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_481_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_current
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	iny
	lda  #0
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	lda  p8v_current
	rts
label_asm_481_afterif
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdarrvars.p8v_r
	sty  p8b_jdarrvars.p8v_r+1
	lda  p8v_current
	sta  p8b_jdarrvars.p8v_cn
	
p8l_label_117_untilloop
	inc  p8b_jdarrvars.p8v_cn
	lda  p8b_jdarrvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_name,y
	ldx  p8b_jdarrvars.p8v_arrvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8l_label_117_untilloop
	lda  p8b_jdarrvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_r
	sta  p8b_jdarrvars.p8v_arrvars_name,y
	lda  p8b_jdarrvars.p8v_r+1
	sta  p8b_jdarrvars.p8v_arrvars_name+1,y
	lda  p8b_jdarrvars.p8v_cn
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_cn
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	iny
	lda  #0
	sta  p8b_jdarrvars.p8v_arrvars_addr,y
	ldx  p8b_jdarrvars.p8v_cn
	stz  p8b_jdarrvars.p8v_arrvars_next,x
	ldy  p8v_current
	lda  p8b_jdarrvars.p8v_cn
	sta  p8b_jdarrvars.p8v_arrvars_next,y
label_asm_478_afterif
	lda  p8b_jdarrvars.p8v_cn
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_value	.proc
; statements
	stz  p8v_taddr
	stz  p8v_taddr+1
	stz  p8v_tind
	stz  p8v_tind+1
	stz  p8v_value
	stz  p8v_value+1
	stz  p8v_l
	stz  p8v_m
	lda  p8v_nr
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_addr,y
	ldx  p8b_jdarrvars.p8v_arrvars_addr+1,y
	sta  p8v_taddr
	stx  p8v_taddr+1
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_l
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_tind
	sty  p8v_tind+1
	lda  p8v_taddr
	bne  +
	dec  p8v_taddr+1
+                           dec  p8v_taddr
	lda  p8v_taddr
	bne  +
	dec  p8v_taddr+1
+                           dec  p8v_taddr
	ldy  p8v_index+1
	lda  p8v_index
	cmp  p8v_tind
	tya
	sbc  p8v_tind+1
	bcs  label_asm_482_afterif
	inc  p8v_index
	bne  +
	inc  p8v_index+1
+
	ldy  p8v_index+1
	lda  p8v_index
	sty  P8ZP_SCRATCH_B1
	asl  a
	rol  P8ZP_SCRATCH_B1
	ldy  P8ZP_SCRATCH_B1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  p8v_taddr
	sec
	sbc  P8ZP_SCRATCH_W1
	sta  p8v_taddr
	lda  p8v_taddr+1
	sbc  P8ZP_SCRATCH_W1+1
	sta  p8v_taddr+1
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_l
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_value
	sty  p8v_value+1
label_asm_482_afterif
	ldy  p8v_value+1
	lda  p8v_value
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.word  ?
p8v_l	.byte  ?
p8v_m	.byte  ?
p8v_nr	.byte  ?
p8v_taddr	.word  ?
p8v_tind	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_len	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_nr
; statements
	stz  p8v_taddr
	stz  p8v_taddr+1
	stz  p8v_tind
	stz  p8v_tind+1
	stz  p8v_l
	stz  p8v_m
	lda  p8v_nr
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_addr,y
	ldx  p8b_jdarrvars.p8v_arrvars_addr+1,y
	sta  p8v_taddr
	stx  p8v_taddr+1
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_l
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_tind
	sty  p8v_tind+1
	lda  p8v_tind
	bne  +
	dec  p8v_tind+1
+                           dec  p8v_tind
	ldy  p8v_tind+1
	lda  p8v_tind
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_l	.byte  ?
p8v_m	.byte  ?
p8v_nr	.byte  ?
p8v_taddr	.word  ?
p8v_tind	.word  ?
	.send BSS
	.pend

p8s_set_value	.proc
; statements
	stz  p8v_taddr
	stz  p8v_taddr+1
	stz  p8v_tind
	stz  p8v_tind+1
	stz  p8v_l
	stz  p8v_m
	lda  p8v_nr
	asl  a
	tay
	lda  p8b_jdarrvars.p8v_arrvars_addr,y
	ldx  p8b_jdarrvars.p8v_arrvars_addr+1,y
	sta  p8v_taddr
	stx  p8v_taddr+1
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_l
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_taddr
	ldy  p8v_taddr+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1)
	sta  p8v_m
	lda  p8v_l
	ldy  p8v_m
	sta  p8v_tind
	sty  p8v_tind+1
	lda  p8v_taddr
	bne  +
	dec  p8v_taddr+1
+                           dec  p8v_taddr
	lda  p8v_taddr
	bne  +
	dec  p8v_taddr+1
+                           dec  p8v_taddr
	ldy  p8v_index+1
	lda  p8v_index
	cmp  p8v_tind
	tya
	sbc  p8v_tind+1
	bcs  label_asm_483_afterif
	inc  p8v_index
	bne  +
	inc  p8v_index+1
+
	ldy  p8v_index+1
	lda  p8v_index
	sty  P8ZP_SCRATCH_B1
	asl  a
	rol  P8ZP_SCRATCH_B1
	ldy  P8ZP_SCRATCH_B1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	lda  p8v_taddr
	sec
	sbc  P8ZP_SCRATCH_W1
	sta  p8v_taddr
	lda  p8v_taddr+1
	sbc  P8ZP_SCRATCH_W1+1
	sta  p8v_taddr+1
	lda  p8v_value
	ldy  p8v_taddr
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_taddr+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	inc  p8v_taddr
	bne  +
	inc  p8v_taddr+1
+
	lda  p8v_value+1
	ldy  p8v_taddr
	sty  P8ZP_SCRATCH_W2
	ldy  p8v_taddr+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
label_asm_483_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.word  ?
p8v_l	.byte  ?
p8v_m	.byte  ?
p8v_nr	.byte  ?
p8v_taddr	.word  ?
p8v_tind	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_jdlocal' ----
p8b_jdlocal	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cn	.byte  ?
p8v_localvars_name	.fill  256
p8v_localvars_next	.fill  128
p8v_localvars_value	.fill  256
p8v_r	.word  ?
	.send BSS
; non-zeropage variables
p8v_buffer	; PETSCII:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00


p8s_insert	.proc
; statements
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_484_afterif
	lda  #1
	sta  p8v_index
label_asm_484_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_486_else
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdlocal.p8v_r
	sty  p8b_jdlocal.p8v_r+1
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdlocal.p8v_r
	sta  p8b_jdlocal.p8v_localvars_name,y
	lda  p8b_jdlocal.p8v_r+1
	sta  p8b_jdlocal.p8v_localvars_name+1,y
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdlocal.p8v_localvars_value,y
	lda  p8v_value+1
	sta  p8b_jdlocal.p8v_localvars_value+1,y
	ldx  p8v_index
	stz  p8b_jdlocal.p8v_localvars_next,x
	lda  p8v_index
	rts
label_asm_486_else
	lda  p8v_index
	sta  p8v_current
	
p8l_label_118_whileloop
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_localvars_next,y
	beq  p8l_label_119_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdlocal.p8v_buffer
	ldy  #>p8b_jdlocal.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdlocal.p8v_buffer
	lda  #<p8b_jdlocal.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_487_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdlocal.p8v_localvars_value,y
	lda  p8v_value+1
	sta  p8b_jdlocal.p8v_localvars_value+1,y
	lda  p8v_current
	rts
label_asm_487_afterif
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_localvars_next,y
	sta  p8v_current
	bra  p8l_label_118_whileloop
p8l_label_119_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdlocal.p8v_buffer
	ldy  #>p8b_jdlocal.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdlocal.p8v_buffer
	lda  #<p8b_jdlocal.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_488_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdlocal.p8v_localvars_value,y
	lda  p8v_value+1
	sta  p8b_jdlocal.p8v_localvars_value+1,y
	lda  p8v_current
	rts
label_asm_488_afterif
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdlocal.p8v_r
	sty  p8b_jdlocal.p8v_r+1
p8l_label_120_untilloop
	inc  p8b_jdlocal.p8v_cn
	lda  p8b_jdlocal.p8v_cn
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8l_label_120_untilloop
	lda  p8b_jdlocal.p8v_cn
	asl  a
	tay
	lda  p8b_jdlocal.p8v_r
	sta  p8b_jdlocal.p8v_localvars_name,y
	lda  p8b_jdlocal.p8v_r+1
	sta  p8b_jdlocal.p8v_localvars_name+1,y
	lda  p8b_jdlocal.p8v_cn
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdlocal.p8v_localvars_value,y
	lda  p8v_value+1
	sta  p8b_jdlocal.p8v_localvars_value+1,y
	ldx  p8b_jdlocal.p8v_cn
	stz  p8b_jdlocal.p8v_localvars_next,x
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_cn
	sta  p8b_jdlocal.p8v_localvars_next,y
label_asm_485_afterif
	lda  p8b_jdlocal.p8v_cn
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_name	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_name
	sty  p8v_name+1
; statements
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_489_afterif
	lda  #1
	sta  p8v_index
label_asm_489_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_490_afterif
	lda  #0
	tay
	rts
label_asm_490_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdlocal.p8v_buffer
	ldy  #>p8b_jdlocal.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	ldy  p8v_index
	lda  p8b_jdlocal.p8v_localvars_next,y
	sta  p8v_current
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdlocal.p8v_buffer
	lda  #<p8b_jdlocal.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_491_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_value,y
	ldx  p8b_jdlocal.p8v_localvars_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_491_afterif
p8l_label_121_whileloop
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_localvars_next,y
	beq  p8l_label_122_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdlocal.p8v_buffer
	ldy  #>p8b_jdlocal.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdlocal.p8v_buffer
	lda  #<p8b_jdlocal.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_492_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_value,y
	ldx  p8b_jdlocal.p8v_localvars_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_492_afterif
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_localvars_next,y
	sta  p8v_current
	bra  p8l_label_121_whileloop
p8l_label_122_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdlocal.p8v_buffer
	ldy  #>p8b_jdlocal.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdlocal.p8v_buffer
	lda  #<p8b_jdlocal.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_493_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_value,y
	ldx  p8b_jdlocal.p8v_localvars_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_493_afterif
	lda  #0
	tay
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
	.send BSS
	.pend

p8s_get_indexbyname	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_name
	sty  p8v_name+1
; statements
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_494_afterif
	lda  #1
	sta  p8v_index
label_asm_494_afterif
	ldy  p8v_index
	lda  p8b_jdlocal.p8v_localvars_next,y
	sta  p8v_current
	bne  label_asm_495_afterif
	lda  p8v_index
	rts
label_asm_495_afterif
p8l_label_123_whileloop
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_localvars_next,y
	beq  p8l_label_124_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_name,y
	ldx  p8b_jdlocal.p8v_localvars_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdlocal.p8v_buffer
	ldy  #>p8b_jdlocal.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdlocal.p8v_buffer
	lda  #<p8b_jdlocal.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_496_afterif
	lda  p8v_current
	rts
label_asm_496_afterif
	ldy  p8v_current
	lda  p8b_jdlocal.p8v_localvars_next,y
	sta  p8v_current
	bra  p8l_label_123_whileloop
p8l_label_124_afterwhile
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
	.send BSS
	.pend

p8s_get_value	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_index
; statements
	asl  a
	tay
	lda  p8b_jdlocal.p8v_localvars_value,y
	ldx  p8b_jdlocal.p8v_localvars_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
	.send BSS
	.pend

p8s_set_value	.proc
; statements
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdlocal.p8v_localvars_value,y
	lda  p8v_value+1
	sta  p8b_jdlocal.p8v_localvars_value+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
p8v_value	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_labels' ----
p8b_labels	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cn	.byte  ?
p8v_label_name	.fill  128
p8v_label_next	.fill  64
p8v_label_value	.fill  128
p8v_r	.word  ?
	.send BSS
; non-zeropage variables
p8v_buffer	; PETSCII:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00


p8s_insert	.proc
; statements
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_497_afterif
	lda  #1
	sta  p8v_index
label_asm_497_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_labels.p8v_label_name,y
	ldx  p8b_labels.p8v_label_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_499_else
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_labels.p8v_r
	sty  p8b_labels.p8v_r+1
	lda  p8v_index
	asl  a
	tay
	lda  p8b_labels.p8v_r
	sta  p8b_labels.p8v_label_name,y
	lda  p8b_labels.p8v_r+1
	sta  p8b_labels.p8v_label_name+1,y
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_labels.p8v_label_value,y
	lda  p8v_value+1
	sta  p8b_labels.p8v_label_value+1,y
	ldx  p8v_index
	stz  p8b_labels.p8v_label_next,x
	lda  p8v_index
	rts
label_asm_499_else
	lda  p8v_index
	sta  p8v_current
	
p8l_label_125_whileloop
	ldy  p8v_current
	lda  p8b_labels.p8v_label_next,y
	beq  p8l_label_126_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_labels.p8v_label_name,y
	ldx  p8b_labels.p8v_label_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_labels.p8v_buffer
	ldy  #>p8b_labels.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_labels.p8v_buffer
	lda  #<p8b_labels.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_500_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_labels.p8v_label_value,y
	lda  p8v_value+1
	sta  p8b_labels.p8v_label_value+1,y
	lda  p8v_current
	rts
label_asm_500_afterif
	ldy  p8v_current
	lda  p8b_labels.p8v_label_next,y
	sta  p8v_current
	bra  p8l_label_125_whileloop
p8l_label_126_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_labels.p8v_label_name,y
	ldx  p8b_labels.p8v_label_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_labels.p8v_buffer
	ldy  #>p8b_labels.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_labels.p8v_buffer
	lda  #<p8b_labels.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_501_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_labels.p8v_label_value,y
	lda  p8v_value+1
	sta  p8b_labels.p8v_label_value+1,y
	lda  p8v_current
	rts
label_asm_501_afterif
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_labels.p8v_r
	sty  p8b_labels.p8v_r+1
p8l_label_127_untilloop
	inc  p8b_labels.p8v_cn
	lda  p8b_labels.p8v_cn
	asl  a
	tay
	lda  p8b_labels.p8v_label_name,y
	ldx  p8b_labels.p8v_label_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8l_label_127_untilloop
	lda  p8b_labels.p8v_cn
	asl  a
	tay
	lda  p8b_labels.p8v_r
	sta  p8b_labels.p8v_label_name,y
	lda  p8b_labels.p8v_r+1
	sta  p8b_labels.p8v_label_name+1,y
	lda  p8b_labels.p8v_cn
	asl  a
	tay
	lda  p8v_value
	sta  p8b_labels.p8v_label_value,y
	lda  p8v_value+1
	sta  p8b_labels.p8v_label_value+1,y
	ldx  p8b_labels.p8v_cn
	stz  p8b_labels.p8v_label_next,x
	ldy  p8v_current
	lda  p8b_labels.p8v_cn
	sta  p8b_labels.p8v_label_next,y
label_asm_498_afterif
	lda  p8b_labels.p8v_cn
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_jmpaddress	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_name
	sty  p8v_name+1
; statements
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_502_afterif
	lda  #1
	sta  p8v_index
label_asm_502_afterif
	ldy  p8v_index
	lda  p8b_labels.p8v_label_next,y
	sta  p8v_current
	bne  label_asm_503_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_labels.p8v_label_value,y
	ldx  p8b_labels.p8v_label_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_503_afterif
p8l_label_128_whileloop
	ldy  p8v_current
	lda  p8b_labels.p8v_label_next,y
	beq  p8l_label_129_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_labels.p8v_label_name,y
	ldx  p8b_labels.p8v_label_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_labels.p8v_buffer
	ldy  #>p8b_labels.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_labels.p8v_buffer
	lda  #<p8b_labels.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_504_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8b_labels.p8v_label_value,y
	ldx  p8b_labels.p8v_label_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_504_afterif
	ldy  p8v_current
	lda  p8b_labels.p8v_label_next,y
	sta  p8v_current
	bra  p8l_label_128_whileloop
p8l_label_129_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_labels.p8v_label_name,y
	ldx  p8b_labels.p8v_label_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_labels.p8v_buffer
	ldy  #>p8b_labels.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_labels.p8v_buffer
	lda  #<p8b_labels.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_505_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8b_labels.p8v_label_value,y
	ldx  p8b_labels.p8v_label_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
label_asm_505_afterif
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
	.send BSS
	.pend

p8s_set_value	.proc
; statements
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_labels.p8v_label_value,y
	lda  p8v_value+1
	sta  p8b_labels.p8v_label_value+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
p8v_value	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_jdfunc' ----
p8b_jdfunc	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cn	.byte  ?
p8v_func_name	.fill  128
p8v_func_next	.fill  64
p8v_func_stack	.fill  64
p8v_func_value	.fill  128
p8v_r	.word  ?
	.send BSS
; non-zeropage variables
p8v_buffer	; PETSCII:"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	.byte  $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte  $00, $00


p8s_insert	.proc
; statements
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_506_afterif
	lda  #1
	sta  p8v_index
label_asm_506_afterif
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  label_asm_508_else
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdfunc.p8v_r
	sty  p8b_jdfunc.p8v_r+1
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdfunc.p8v_r
	sta  p8b_jdfunc.p8v_func_name,y
	lda  p8b_jdfunc.p8v_r+1
	sta  p8b_jdfunc.p8v_func_name+1,y
	lda  p8v_index
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdfunc.p8v_func_value,y
	lda  p8v_value+1
	sta  p8b_jdfunc.p8v_func_value+1,y
	ldx  p8v_index
	stz  p8b_jdfunc.p8v_func_next,x
	ldx  p8v_index
	stz  p8b_jdfunc.p8v_func_stack,x
	lda  p8v_index
	rts
label_asm_508_else
	lda  p8v_index
	sta  p8v_current
	
p8l_label_130_whileloop
	ldy  p8v_current
	lda  p8b_jdfunc.p8v_func_next,y
	beq  p8l_label_131_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdfunc.p8v_buffer
	ldy  #>p8b_jdfunc.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdfunc.p8v_buffer
	lda  #<p8b_jdfunc.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_509_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdfunc.p8v_func_value,y
	lda  p8v_value+1
	sta  p8b_jdfunc.p8v_func_value+1,y
	lda  p8v_current
	rts
label_asm_509_afterif
	ldy  p8v_current
	lda  p8b_jdfunc.p8v_func_next,y
	sta  p8v_current
	bra  p8l_label_130_whileloop
p8l_label_131_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdfunc.p8v_buffer
	ldy  #>p8b_jdfunc.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdfunc.p8v_buffer
	lda  #<p8b_jdfunc.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_510_afterif
	lda  p8v_current
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdfunc.p8v_func_value,y
	lda  p8v_value+1
	sta  p8b_jdfunc.p8v_func_value+1,y
	lda  p8v_current
	rts
label_asm_510_afterif
	ldy  p8v_name+1
	lda  p8v_name
	jsr  p8b_jdstr.p8s_add
	sta  p8b_jdfunc.p8v_r
	sty  p8b_jdfunc.p8v_r+1
p8l_label_132_untilloop
	inc  p8b_jdfunc.p8v_cn
	lda  p8b_jdfunc.p8v_cn
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8l_label_132_untilloop
	lda  p8b_jdfunc.p8v_cn
	asl  a
	tay
	lda  p8b_jdfunc.p8v_r
	sta  p8b_jdfunc.p8v_func_name,y
	lda  p8b_jdfunc.p8v_r+1
	sta  p8b_jdfunc.p8v_func_name+1,y
	lda  p8b_jdfunc.p8v_cn
	asl  a
	tay
	lda  p8v_value
	sta  p8b_jdfunc.p8v_func_value,y
	lda  p8v_value+1
	sta  p8b_jdfunc.p8v_func_value+1,y
	ldx  p8b_jdfunc.p8v_cn
	stz  p8b_jdfunc.p8v_func_next,x
	ldx  p8b_jdfunc.p8v_cn
	stz  p8b_jdfunc.p8v_func_stack,x
	ldy  p8v_current
	lda  p8b_jdfunc.p8v_cn
	sta  p8b_jdfunc.p8v_func_next,y
label_asm_507_afterif
	lda  p8b_jdfunc.p8v_cn
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
p8v_value	.word  ?
	.send BSS
	.pend

p8s_get_FuncNoByName	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_name
	sty  p8v_name+1
; statements
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	jsr  string.hash
	lsr  a
	lsr  a
	sta  p8v_index
	lda  p8v_index
	bne  label_asm_511_afterif
	lda  #1
	sta  p8v_index
label_asm_511_afterif
	lda  p8v_index
	beq  +
	lda  #1
+                           eor  #1
	beq  label_asm_512_shortcut
	lda  p8v_index
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	sty  P8ZP_SCRATCH_B1
	ora  P8ZP_SCRATCH_B1
label_asm_512_shortcut
	beq  label_asm_513_afterif
	lda  p8v_index
	rts
label_asm_513_afterif
	lda  p8v_index
	sta  p8v_current
	
p8l_label_135_whileloop
	ldy  p8v_current
	lda  p8b_jdfunc.p8v_func_next,y
	beq  p8l_label_136_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdfunc.p8v_buffer
	ldy  #>p8b_jdfunc.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdfunc.p8v_buffer
	lda  #<p8b_jdfunc.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_514_afterif
	lda  p8v_current
	rts
label_asm_514_afterif
	ldy  p8v_current
	lda  p8b_jdfunc.p8v_func_next,y
	sta  p8v_current
	bra  p8l_label_135_whileloop
p8l_label_136_afterwhile
	lda  p8v_current
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_name,y
	ldx  p8b_jdfunc.p8v_func_name+1,y
	sta  p8b_jdstr.p8s_get.p8v_prt
	stx  p8b_jdstr.p8s_get.p8v_prt+1
	lda  #<p8b_jdfunc.p8v_buffer
	ldy  #>p8b_jdfunc.p8v_buffer
	sta  p8b_jdstr.p8s_get.p8v_buf
	sty  p8b_jdstr.p8s_get.p8v_buf+1
	jsr  p8b_jdstr.p8s_get
	lda  p8v_name
	sta  cx16.r0
	lda  p8v_name+1
	sta  cx16.r0+1
	
	ldy  #>p8b_jdfunc.p8v_buffer
	lda  #<p8b_jdfunc.p8v_buffer
	jsr  string.compare
	cmp  #0
	bne  label_asm_515_afterif
	lda  p8v_current
	rts
label_asm_515_afterif
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_current	.byte  ?
p8v_index	.byte  ?
p8v_name	.word  ?
	.send BSS
	.pend

p8s_get_value	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_index
; statements
	asl  a
	tay
	lda  p8b_jdfunc.p8v_func_value,y
	ldx  p8b_jdfunc.p8v_func_value+1,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
	.send BSS
	.pend

p8s_get_stack	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_index
; statements
	ldy  p8v_index
	lda  p8b_jdfunc.p8v_func_stack,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
	.send BSS
	.pend

p8s_set_stack	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_index
	sty  p8v_value
; statements
	ldy  p8v_index
	lda  p8v_value
	sta  p8b_jdfunc.p8v_func_stack,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_index	.byte  ?
p8v_value	.byte  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_ifstack' ----
p8b_ifstack	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_eifeadd	.fill  32
p8v_elseadd	.fill  32
p8v_isc	.byte  ?
p8v_thenadd	.fill  32
p8v_val	.word  ?
	.send BSS


p8s_push	.proc
; statements
	inc  p8b_ifstack.p8v_isc
	lda  p8b_ifstack.p8v_isc
	asl  a
	tay
	lda  p8v_elseaddress
	sta  p8b_ifstack.p8v_elseadd,y
	lda  p8v_elseaddress+1
	sta  p8b_ifstack.p8v_elseadd+1,y
	lda  p8b_ifstack.p8v_isc
	asl  a
	tay
	lda  p8v_thenaddress
	sta  p8b_ifstack.p8v_thenadd,y
	lda  p8v_thenaddress+1
	sta  p8b_ifstack.p8v_thenadd+1,y
	lda  p8b_ifstack.p8v_isc
	asl  a
	tay
	lda  p8v_endifaddress
	sta  p8b_ifstack.p8v_eifeadd,y
	lda  p8v_endifaddress+1
	sta  p8b_ifstack.p8v_eifeadd+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_elseaddress	.word  ?
p8v_endifaddress	.word  ?
p8v_thenaddress	.word  ?
	.send BSS
	.pend

p8s_pops	.proc
; statements
	lda  p8b_ifstack.p8v_isc
	asl  a
	tay
	lda  p8b_ifstack.p8v_elseadd,y
	ldx  p8b_ifstack.p8v_elseadd+1,y
	sta  p8b_ifstack.p8v_val
	stx  p8b_ifstack.p8v_val+1
	ldy  p8b_ifstack.p8v_val+1
	lda  p8b_ifstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_popm	.proc
; statements
	lda  p8b_ifstack.p8v_isc
	asl  a
	tay
	lda  p8b_ifstack.p8v_thenadd,y
	ldx  p8b_ifstack.p8v_thenadd+1,y
	sta  p8b_ifstack.p8v_val
	stx  p8b_ifstack.p8v_val+1
	ldy  p8b_ifstack.p8v_val+1
	lda  p8b_ifstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_pope	.proc
; statements
	lda  p8b_ifstack.p8v_isc
	asl  a
	tay
	lda  p8b_ifstack.p8v_eifeadd,y
	ldx  p8b_ifstack.p8v_eifeadd+1,y
	sta  p8b_ifstack.p8v_val
	stx  p8b_ifstack.p8v_val+1
	dec  p8b_ifstack.p8v_isc
	ldy  p8b_ifstack.p8v_val+1
	lda  p8b_ifstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_funcstack' ----
p8b_funcstack	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_fsc	.byte  ?
p8v_retaddr	.fill  64
p8v_val	.word  ?
	.send BSS


p8s_push	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_retaddr1
	sty  p8v_retaddr1+1
; statements
	inc  p8b_funcstack.p8v_fsc
	lda  p8b_funcstack.p8v_fsc
	asl  a
	tay
	lda  p8v_retaddr1
	sta  p8b_funcstack.p8v_retaddr,y
	lda  p8v_retaddr1+1
	sta  p8b_funcstack.p8v_retaddr+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_retaddr1	.word  ?
	.send BSS
	.pend

p8s_pop	.proc
; statements
	lda  p8b_funcstack.p8v_fsc
	asl  a
	tay
	lda  p8b_funcstack.p8v_retaddr,y
	ldx  p8b_funcstack.p8v_retaddr+1,y
	sta  p8b_funcstack.p8v_val
	stx  p8b_funcstack.p8v_val+1
	dec  p8b_funcstack.p8v_fsc
	ldy  p8b_funcstack.p8v_val+1
	lda  p8b_funcstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_forstack' ----
p8b_forstack	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_for_from	.fill  32
p8v_for_step	.fill  32
p8v_for_to	.fill  32
p8v_for_var_num	.fill  16
p8v_for_var_type	.fill  16
p8v_osc	.byte  ?
p8v_start_address_code	.fill  32
p8v_val	.word  ?
p8v_valb	.byte  ?
	.send BSS


p8s_push	.proc
; statements
	inc  p8b_forstack.p8v_osc
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8v_start_address_code1
	sta  p8b_forstack.p8v_start_address_code,y
	lda  p8v_start_address_code1+1
	sta  p8b_forstack.p8v_start_address_code+1,y
	ldy  p8b_forstack.p8v_osc
	lda  p8v_var_type
	sta  p8b_forstack.p8v_for_var_type,y
	ldy  p8b_forstack.p8v_osc
	lda  p8v_var_num
	sta  p8b_forstack.p8v_for_var_num,y
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8v_for_from_val
	sta  p8b_forstack.p8v_for_from,y
	lda  p8v_for_from_val+1
	sta  p8b_forstack.p8v_for_from+1,y
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8v_for_to_val
	sta  p8b_forstack.p8v_for_to,y
	lda  p8v_for_to_val+1
	sta  p8b_forstack.p8v_for_to+1,y
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8v_for_step_val
	sta  p8b_forstack.p8v_for_step,y
	lda  p8v_for_step_val+1
	sta  p8b_forstack.p8v_for_step+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_for_from_val	.word  ?
p8v_for_step_val	.word  ?
p8v_for_to_val	.word  ?
p8v_start_address_code1	.word  ?
p8v_var_num	.byte  ?
p8v_var_type	.byte  ?
	.send BSS
	.pend

p8s_pop1	.proc
; statements
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8b_forstack.p8v_start_address_code,y
	ldx  p8b_forstack.p8v_start_address_code+1,y
	sta  p8b_forstack.p8v_val
	stx  p8b_forstack.p8v_val+1
	ldy  p8b_forstack.p8v_val+1
	lda  p8b_forstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_pop3	.proc
; statements
	ldy  p8b_forstack.p8v_osc
	lda  p8b_forstack.p8v_for_var_num,y
	sta  p8b_forstack.p8v_valb
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_pop5	.proc
; statements
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8b_forstack.p8v_for_to,y
	ldx  p8b_forstack.p8v_for_to+1,y
	sta  p8b_forstack.p8v_val
	stx  p8b_forstack.p8v_val+1
	ldy  p8b_forstack.p8v_val+1
	lda  p8b_forstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_pop6	.proc
; statements
	lda  p8b_forstack.p8v_osc
	asl  a
	tay
	lda  p8b_forstack.p8v_for_step,y
	ldx  p8b_forstack.p8v_for_step+1,y
	sta  p8b_forstack.p8v_val
	stx  p8b_forstack.p8v_val+1
	ldy  p8b_forstack.p8v_val+1
	lda  p8b_forstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_pope	.proc
; statements
	dec  p8b_forstack.p8v_osc
	lda  #0
	tay
	rts
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_varstack' ----
p8b_varstack	.proc
p8v_vsc 	= 47 	; zp UBYTE
p8v_val 	= 48 	; zp UWORD

; non-zeropage variables without initialization value
	.section BSS
p8v_svar	.fill  16
	.send BSS


p8s_push	.proc
p8v_svar1 	= 50 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  p8v_svar1
	sty  p8v_svar1+1
; statements
	inc  p8b_varstack.p8v_vsc
	lda  p8b_varstack.p8v_vsc
	asl  a
	tay
	lda  p8v_svar1
	sta  p8b_varstack.p8v_svar,y
	lda  p8v_svar1+1
	sta  p8b_varstack.p8v_svar+1,y
	rts
; variables
	.section BSS
	.send BSS

	.pend

p8s_pop	.proc
; statements
	lda  p8b_varstack.p8v_vsc
	asl  a
	tay
	lda  p8b_varstack.p8v_svar,y
	ldx  p8b_varstack.p8v_svar+1,y
	sta  p8b_varstack.p8v_val
	stx  p8b_varstack.p8v_val+1
	dec  p8b_varstack.p8v_vsc
	ldy  p8b_varstack.p8v_val+1
	lda  p8b_varstack.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	stz  p8b_varstack.p8v_val
	stz  p8b_varstack.p8v_val+1
	stz  p8b_varstack.p8v_vsc
	rts
	.bend
	.pend

; ---- block: 'p8b_callstack_b' ----
p8b_callstack_b	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cbsc	.byte  ?
p8v_cbvar	.fill  256
p8v_val	.byte  ?
	.send BSS


p8s_push	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_cbvar1
; statements
	inc  p8b_callstack_b.p8v_cbsc
	ldy  p8b_callstack_b.p8v_cbsc
	lda  p8v_cbvar1
	sta  p8b_callstack_b.p8v_cbvar,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_cbvar1	.byte  ?
	.send BSS
	.pend

p8s_pop	.proc
; statements
	ldy  p8b_callstack_b.p8v_cbsc
	lda  p8b_callstack_b.p8v_cbvar,y
	sta  p8b_callstack_b.p8v_val
	dec  p8b_callstack_b.p8v_cbsc
	lda  p8b_callstack_b.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_callstack_w' ----
p8b_callstack_w	.proc

; non-zeropage variables without initialization value
	.section BSS
p8v_cwsc	.byte  ?
p8v_cwvar	.fill  256
p8v_val	.word  ?
	.send BSS


p8s_push	.proc
; simple int arg(s) passed via register(s)
	sta  p8v_cwvar1
	sty  p8v_cwvar1+1
; statements
	inc  p8b_callstack_w.p8v_cwsc
	lda  p8b_callstack_w.p8v_cwsc
	asl  a
	tay
	lda  p8v_cwvar1
	sta  p8b_callstack_w.p8v_cwvar,y
	lda  p8v_cwvar1+1
	sta  p8b_callstack_w.p8v_cwvar+1,y
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8v_cwvar1	.word  ?
	.send BSS
	.pend

p8s_pop	.proc
; statements
	lda  p8b_callstack_w.p8v_cwsc
	asl  a
	tay
	lda  p8b_callstack_w.p8v_cwvar,y
	ldx  p8b_callstack_w.p8v_cwvar+1,y
	sta  p8b_callstack_w.p8v_val
	stx  p8b_callstack_w.p8v_val+1
	dec  p8b_callstack_w.p8v_cwsc
	ldy  p8b_callstack_w.p8v_val+1
	lda  p8b_callstack_w.p8v_val
	rts
; variables
	.section BSS
	.send BSS

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'math' ----
math	.proc


; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	http://codebase64.org/doku.php?id=base:6502_6510_maths
;       https://github.com/TobyLobster/multiply_test
;       https://github.com/TobyLobster/sqrt_test


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
	; https://github.com/TobyLobster/multiply_test/blob/main/tests/mult29.a

_multiplicand    = P8ZP_SCRATCH_B1
_multiplier      = P8ZP_SCRATCH_REG

    sty  _multiplicand
    lsr  a
    sta  _multiplier
    lda  #0
    ldx  #2
-
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier

    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    dex
    bne  -
    ; tay       ; if you want 16 bits result in AY, enable this again
    lda  _multiplier
    rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (signed and unsigned)
	;      input: A/Y = first 16-bit number, multiply_words.multiplier = second 16-bit number
	;      output: multiply_words.result, 4-bytes/32-bits product, LSB order (low-to-high)  low 16 bits also in AY.

	; NOTE: the result (which includes the multiplier parameter on entry) is a 4-byte array.
	;       this routine could be faster if we could stick that into zeropage,
	;       but there currently is no way to use 4 consecutive bytes in ZP (without disabling irq and saving/restoring them)...

; mult62.a
; from: https://github.com/TobyLobster/multiply_test/blob/main/tests/mult62.a
; based on Dr Jefyll, http://forum.6502.org/viewtopic.php?f=9&t=689&start=0#p19958
; - adjusted to use fixed zero page addresses
; - removed 'decrement to avoid clc' as this is slower on average
; - rearranged memory use to remove final memory copy and give LSB first order to result
; - removed temp zp storage bytes
; - unrolled the outer loop
; - unrolled the two inner loops once
;
; 16 bit x 16 bit unsigned multiply, 32 bit result
; Average cycles: ~442 ?
; 93 bytes

_multiplicand    = P8ZP_SCRATCH_W2   ; 2 bytes
multiplier      = result

; 16 bit x 16 bit unsigned multiply, 32 bit result
;
; On Entry:
;   (multiplier, multiplier+1): two byte multiplier, four bytes needed for result
;   (multiplicand, multiplicand+1): two byte multiplicand
; On Exit:
;   (result, result+1, result+2, result+3): product

    sta  _multiplicand
    sty  _multiplicand+1

    lda  #0              ;
    sta  result+2        ; 16 bits of zero in A, result+2
                        ;  Note:    First 8 shifts are  A -> result+2 -> result
                        ;           Final 8 shifts are  A -> result+2 -> result+1

    ; --- 1st byte ---
    ldy  #4              ; count for inner loop
    lsr  result

    ; inner loop (8 times)
_inner_loop
    ; first time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result

    ; second time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                 ; shift
    ror  result+2
    ror  result

    dey
    bne  _inner_loop      ; go back for 1 more shift?

    ; --- 2nd byte ---
    ldy  #4              ; count for inner loop
    lsr  result+1

    ; inner loop (8 times)
_inner_loop2
    ; first time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1

    ; second time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1
    dey
    bne  _inner_loop2     ; go back for 1 more shift?

    sta  result+3        ; ms byte of hi-word of result

    lda  result
    ldy  result+1
    rts

result		.byte  0,0,0,0

		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_B1
		tya
		eor  P8ZP_SCRATCH_B1
		php			; save sign
		lda  P8ZP_SCRATCH_B1
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
_remainder	.byte  0
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1

		lda  #0
		ldx  #8
		asl  P8ZP_SCRATCH_B1
-		rol  a
		cmp  P8ZP_SCRATCH_REG
		bcc  +
		sbc  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1+1
		eor  P8ZP_SCRATCH_W2+1
		php			; save sign
		lda  P8ZP_SCRATCH_W1+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W1
		lda  #0
		sbc  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W2+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W2
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W2+1
+		tay
		lda  P8ZP_SCRATCH_W2
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		pha
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  P8ZP_SCRATCH_W1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: P8ZP_SCRATCH_W2 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident


dividend = P8ZP_SCRATCH_W1
remainder = P8ZP_SCRATCH_W2
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		rts
_divisor	.word 0
		.pend


randword	.proc
	; -- 16 bit pseudo random number generator into AY
	;    default seed = $00c2 $1137
        ;    routine from https://codebase64.org/doku.php?id=base:x_abc_random_number_generator_8_16_bit
		inc x1
		clc
x1=*+1
		lda #$00	;x1
c1=*+1
		eor #$c2	;c1
a1=*+1
		eor #$11	;a1
		sta a1
b1=*+1
		adc #$37	;b1
		sta b1
		lsr a
		eor a1
		adc c1
		sta c1
		ldy b1
		rts
		.pend

randbyte = randword    ; -- 8 bit pseudo random number generator into A (by just reusing randword)


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
                adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		tay
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		tya
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ZP_SCRATCH_REG
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  P8ZP_SCRATCH_B1
		ldy  #0
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		pha
		clc
		lda  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_REG
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y
		cpy  #0
		beq  +
		cmp  #0
		bpl  lsr_ubyte_A
-       	sec
		ror  a
		dey
		bne  -
+		rts
		.pend

lsr_ubyte_A	.proc
		; -- lsr unsigned byte in A times the value in Y
		cpy  #0
		beq  +
-		lsr  a
		dey
		bne  -
+		rts
		.pend

asl_byte_A      .proc
		; -- asl any byte in A times the value in Y
		cpy  #0
		beq  +
-		asl  a
		dey
		bne  -
+		rts
		.pend


lsr_word_AY     .proc
		; -- lsr signed word in AY times the value in X
		cpx  #0
		beq  +
		cpy  #0
		bpl  lsr_uword_AY
		sty  P8ZP_SCRATCH_B1
-		sec
		ror  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

lsr_uword_AY    .proc
		; -- lsr unsigned word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-		lsr  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

asl_word_AY     .proc
		; -- asl any word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-               asl  a
		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend


square          .proc
; -- calculate square of signed word (actually -255..255) in AY, result in AY
; routine by Lee Davison, source: http://6502.org/source/integers/square.htm
; using this routine is a lot faster as doing a regular multiplication (for words)
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = P8ZP_SCRATCH_W1       ; number to square low byte
numberh = P8ZP_SCRATCH_W1+1     ; number to square high byte
squarel = P8ZP_SCRATCH_W2       ; square low byte
squareh = P8ZP_SCRATCH_W2+1     ; square high byte
tempsq = P8ZP_SCRATCH_B1        ; temp byte for intermediate result

	sta  numberl
	sty  numberh

        lda     #$00        ; clear a
        sta     squarel     ; clear square low byte
                            ; (no need to clear the high byte, it gets shifted out)
        lda	numberl     ; get number low byte
	ldx	numberh     ; get number high  byte
	bpl	_nonneg      ; if +ve don't negate it
                            ; else do a two's complement
	eor	#$ff        ; invert
        sec	            ; +1
	adc	#$00        ; and add it

_nonneg:
	sta	tempsq      ; save abs(number)
	ldx	#$08        ; set bit count

_nextr2bit:
	asl	squarel     ; low byte *2
	rol	squareh     ; high byte *2+carry from low
	asl	a           ; shift number byte
	bcc	_nosqadd     ; don't do add if c = 0
	tay                 ; save a
	clc                 ; clear carry for add
	lda	tempsq      ; get number
	adc	squarel     ; add number^2 low byte
	sta	squarel     ; save number^2 low byte
	lda	#$00        ; clear a
	adc	squareh     ; add number^2 high byte
	sta	squareh     ; save number^2 high byte
	tya                 ; get a back

_nosqadd:
	dex                 ; decrement bit count
	bne	_nextr2bit   ; go do next bit

	lda  squarel
	ldy  squareh
	rts

		.pend

sin8u	.proc
		tay
		lda  _sinecos8u,y
		rts
_sinecos8u	.byte  trunc(128.0 + 127.5 * sin(range(256+64) * rad(360.0/256.0)))
	.pend

cos8u	.proc
		tay
		lda  sin8u._sinecos8u+64,y
		rts
	.pend

sin8	.proc
		tay
		lda  _sinecos8,y
		rts
_sinecos8	.char  trunc(127.0 * sin(range(256+64) * rad(360.0/256.0)))
	.pend

cos8	.proc
		tay
		lda  sin8._sinecos8+64,y
		rts
	.pend

sinr8u	.proc
		tay
		lda  _sinecosR8u,y
		rts
_sinecosR8u	.byte  trunc(128.0 + 127.5 * sin(range(180+45) * rad(360.0/180.0)))
	.pend

cosr8u	.proc
		tay
		lda  sinr8u._sinecosR8u+45,y
		rts
	.pend

sinr8	.proc
		tay
		lda  _sinecosR8,y
		rts
_sinecosR8	.char  trunc(127.0 * sin(range(180+45) * rad(360.0/180.0)))
	.pend

cosr8	.proc
		tay
		lda  sinr8._sinecosR8+45,y
		rts
	.pend

rnd	.proc
            jmp  math.randbyte
	.pend

rndw	.proc
            jmp  math.randword
	.pend

rndseed	.proc
            sta  math.randword.x1
            sty  math.randword.c1
            lda  cx16.r0L
            sta  math.randword.a1
            lda  cx16.r0H
            sta  math.randword.b1
            rts
	.pend

log2	.proc
            sta  P8ZP_SCRATCH_B1
            lda  #$80
            ldy  #7
-           bit  P8ZP_SCRATCH_B1
            beq  +
            rts
+           dey
            bne  +
            rts
+           lsr  a
            bne  -
	.pend

log2w	.proc
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            lda  #<$8000
            sta  cx16.r0
            lda  #>$8000
            sta  cx16.r0+1
            ldy  #15
-           lda  P8ZP_SCRATCH_W1
            and  cx16.r0
            sta  P8ZP_SCRATCH_B1
            lda  P8ZP_SCRATCH_W1+1
            and  cx16.r0+1
            ora  P8ZP_SCRATCH_B1
            beq  +
            rts
+           dey
            bne  +
            rts
+           lsr  cx16.r0+1
            ror  cx16.r0
            jmp  -
	.pend

mul16_last_upper	.proc
            lda  multiply_words.result+2
            ldy  multiply_words.result+3
            rts
	.pend

direction_qd	.proc
x_delta = cx16.r0L
y_delta = cx16.r1L
quadrant = cx16.r2L
half_value = cx16.r3L
region_number = cx16.r4L
small = cx16.r5L
large = cx16.r5H

  sta quadrant
  sty y_delta
  stx x_delta
  cpx y_delta
  bcs _XGreaterOrEqualY

_XLessY:
  lda #16
  sta region_number
  stx small
  sty large
  bne _DetermineRegion

_XGreaterOrEqualY:
  lda #0
  sta region_number
  stx large
  sty small

_DetermineRegion:
  ; set A = small * 2.5
  lda small
  lsr a
  sta half_value
  lda small
  asl a
  bcs _SmallerQuotient
  clc
  adc half_value
  bcs _SmallerQuotient
  cmp large
  bcc _LargerQuotient

; S * 2.5 > L
_SmallerQuotient:
  ; set A = S * 1.25
  lsr half_value
  lda small
  clc
  adc half_value
  cmp large
  bcc _Region1 ; if S * 1.25 < L then goto Region1 (L / S > 1.25)
  bcs _Region0 ;                                   (L / S < 1.25)

; S * 2.5 < L
_LargerQuotient:
  ; set A = S * 7.5
  lda small
  asl a
  asl a
  asl a
  bcs _Region2
  sec
  sbc half_value
  cmp large
  bcc _Region3 ; if S * 7.5 < L then goto Region3 (L / S > 7.5)
  jmp _Region2 ;                                  (L / S < 7.5)

_Region0:
  ; L / S < 1.25. d=3,9,15,21
  jmp _LookupResult

_Region1:
  ; 1.25 < L / S < 2.5. d=2,4,8,10,14,16,20,22
  lda region_number
  clc
  adc #4
  sta region_number
  bpl _LookupResult

_Region2:
  ; 2.5 < L / S < 7.5. d=1,5,7,11,13,17,19,23
  lda region_number
  clc
  adc #8
  sta region_number
  bpl _LookupResult

_Region3:
  ; 7.5 < L / S. d=0,6,12,18
  lda region_number
  clc
  adc #12
  sta region_number

_LookupResult:
  lda quadrant
  clc
  adc region_number
  tax
  lda _quadrant_region_to_direction,x
  rts

_quadrant_region_to_direction:
  .byte  9, 3,15,21
  .byte 10, 2,14,22
  .byte 11, 1,13,23
  .byte 12, 0,12, 0
  .byte  9, 3,15,21
  .byte  8, 4,16,20
  .byte  7, 5,17,19
  .byte  6, 6,18,18
	.pend

atan2	.proc
x1 = cx16.r0L
y1 = cx16.r1L
x2 = cx16.r2L
y2 = cx16.r3L
octant = cx16.r4L			;; temporary zeropage variable

		lda x1
		sec
		sbc x2
		bcs *+4
		eor #$ff
		tax
		rol octant

		lda y1
		sec
		sbc y2
		bcs *+4
		eor #$ff
		tay
		rol octant

		lda log2_tab,x
		sec
		sbc log2_tab,y
		bcc *+4
		eor #$ff
		tax

		lda octant
		rol a
		and #%111
		tay

		lda atan_tab,x
		eor octant_adjust,y
		rts

octant_adjust
		.byte %00111111		;; x+,y+,|x|>|y|
		.byte %00000000		;; x+,y+,|x|<|y|
		.byte %11000000		;; x+,y-,|x|>|y|
		.byte %11111111		;; x+,y-,|x|<|y|
		.byte %01000000		;; x-,y+,|x|>|y|
		.byte %01111111		;; x-,y+,|x|<|y|
		.byte %10111111		;; x-,y-,|x|>|y|
		.byte %10000000		;; x-,y-,|x|<|y|


		;;;;;;;; atan(2^(x/32))*128/pi ;;;;;;;;

atan_tab
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$02,$02,$02
		.byte $02,$02,$02,$02,$02,$02,$02,$02
		.byte $02,$02,$02,$02,$02,$02,$02,$02
		.byte $03,$03,$03,$03,$03,$03,$03,$03
		.byte $03,$03,$03,$03,$03,$04,$04,$04
		.byte $04,$04,$04,$04,$04,$04,$04,$04
		.byte $05,$05,$05,$05,$05,$05,$05,$05
		.byte $06,$06,$06,$06,$06,$06,$06,$06
		.byte $07,$07,$07,$07,$07,$07,$08,$08
		.byte $08,$08,$08,$08,$09,$09,$09,$09
		.byte $09,$0a,$0a,$0a,$0a,$0b,$0b,$0b
		.byte $0b,$0c,$0c,$0c,$0c,$0d,$0d,$0d
		.byte $0d,$0e,$0e,$0e,$0e,$0f,$0f,$0f
		.byte $10,$10,$10,$11,$11,$11,$12,$12
		.byte $12,$13,$13,$13,$14,$14,$15,$15
		.byte $15,$16,$16,$17,$17,$17,$18,$18
		.byte $19,$19,$19,$1a,$1a,$1b,$1b,$1c
		.byte $1c,$1c,$1d,$1d,$1e,$1e,$1f,$1f


		;;;;;;;; log2(x)*32 ;;;;;;;;

log2_tab
		.byte $00,$00,$20,$32,$40,$4a,$52,$59
		.byte $60,$65,$6a,$6e,$72,$76,$79,$7d
		.byte $80,$82,$85,$87,$8a,$8c,$8e,$90
		.byte $92,$94,$96,$98,$99,$9b,$9d,$9e
		.byte $a0,$a1,$a2,$a4,$a5,$a6,$a7,$a9
		.byte $aa,$ab,$ac,$ad,$ae,$af,$b0,$b1
		.byte $b2,$b3,$b4,$b5,$b6,$b7,$b8,$b9
		.byte $b9,$ba,$bb,$bc,$bd,$bd,$be,$bf
		.byte $c0,$c0,$c1,$c2,$c2,$c3,$c4,$c4
		.byte $c5,$c6,$c6,$c7,$c7,$c8,$c9,$c9
		.byte $ca,$ca,$cb,$cc,$cc,$cd,$cd,$ce
		.byte $ce,$cf,$cf,$d0,$d0,$d1,$d1,$d2
		.byte $d2,$d3,$d3,$d4,$d4,$d5,$d5,$d5
		.byte $d6,$d6,$d7,$d7,$d8,$d8,$d9,$d9
		.byte $d9,$da,$da,$db,$db,$db,$dc,$dc
		.byte $dd,$dd,$dd,$de,$de,$de,$df,$df
		.byte $df,$e0,$e0,$e1,$e1,$e1,$e2,$e2
		.byte $e2,$e3,$e3,$e3,$e4,$e4,$e4,$e5
		.byte $e5,$e5,$e6,$e6,$e6,$e7,$e7,$e7
		.byte $e7,$e8,$e8,$e8,$e9,$e9,$e9,$ea
		.byte $ea,$ea,$ea,$eb,$eb,$eb,$ec,$ec
		.byte $ec,$ec,$ed,$ed,$ed,$ed,$ee,$ee
		.byte $ee,$ee,$ef,$ef,$ef,$ef,$f0,$f0
		.byte $f0,$f1,$f1,$f1,$f1,$f1,$f2,$f2
		.byte $f2,$f2,$f3,$f3,$f3,$f3,$f4,$f4
		.byte $f4,$f4,$f5,$f5,$f5,$f5,$f5,$f6
		.byte $f6,$f6,$f6,$f7,$f7,$f7,$f7,$f7
		.byte $f8,$f8,$f8,$f8,$f9,$f9,$f9,$f9
		.byte $f9,$fa,$fa,$fa,$fa,$fa,$fb,$fb
		.byte $fb,$fb,$fb,$fc,$fc,$fc,$fc,$fc
		.byte $fd,$fd,$fd,$fd,$fd,$fd,$fe,$fe
		.byte $fe,$fe,$fe,$ff,$ff,$ff,$ff,$ff
	.pend

diff	.proc
            sty  P8ZP_SCRATCH_REG
            sec
            sbc  P8ZP_SCRATCH_REG
            bcs  +
            eor  #255
            inc  a
+           rts
	.pend

diffw	.proc
            sec
            sbc  cx16.r0L
            sta  cx16.r0L
            tya
            sbc  cx16.r0H
            sta  cx16.r0H
            bcs  +
            eor  #255
            sta  cx16.r0H
            lda  cx16.r0L
            eor  #255
            inc  a
            sta  cx16.r0L
            bne  +
            inc  cx16.r0H
+           lda  cx16.r0L
            ldy  cx16.r0H
            rts
	.pend

crc16_update	.proc
            eor  cx16.r15H
            sta  cx16.r15H
            ldy  #8
-           lda  cx16.r15H
            asl  cx16.r15L
            rol  cx16.r15H
            and  #$80
            beq  +
            lda  cx16.r15H
            eor  #$10
            sta  cx16.r15H
            lda  cx16.r15L
            eor  #$21
            sta  cx16.r15L
+           dey
            bne  -
            rts
	.pend

crc32_update	.proc
            eor  cx16.r15H
            sta  cx16.r15H
            ldy  #8
-           lda  cx16.r15H
            asl  cx16.r14L
            rol  cx16.r14H
            rol  cx16.r15L
            rol  cx16.r15H
            and  #$80
            beq  +
            lda  cx16.r15H
            eor  #$04
            sta  cx16.r15H
            lda  cx16.r15L
            eor  #$c1
            sta  cx16.r15L
            lda  cx16.r14H
            eor  #$1d
            sta  cx16.r14H
            lda  cx16.r14L
            eor  #$b7
            sta  cx16.r14L
+           dey
            bne  -
            rts
	.pend
	.pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc


; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.


orig_stackpointer	.byte  0	; stores the Stack pointer register at program start


read_byte_from_address_in_AY_into_A	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		rts
		.pend


write_byte_X_to_address_in_AY	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		txa
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend


reg_less_uw	.proc
		;  AY < P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		bcc  _true
		bne  _false
		cmp  P8ZP_SCRATCH_W2
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_less_w	.proc
		; -- AY < P8ZP_SCRATCH_W2?
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_uw	.proc
		; AY <= P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  P8ZP_SCRATCH_W2
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_w	.proc
		; -- P8ZP_SCRATCH_W2 <= AY ?   (note: order different from other routines)
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend


memcopy16_up	.proc
	; -- copy memory UP from (P8ZP_SCRATCH_W1) to (P8ZP_SCRATCH_W2) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = P8ZP_SCRATCH_W1
		dest = P8ZP_SCRATCH_W2
		length = P8ZP_SCRATCH_B1   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (P8ZP_SCRATCH_W1), length XY, with value in A.
	;    clobbers X, Y
		stx  P8ZP_SCRATCH_B1
		sty  _save_reg
		ldy  #0
		ldx  _save_reg
		beq  _lastpage

_fullpage	sta  (P8ZP_SCRATCH_W1),y
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  P8ZP_SCRATCH_B1
		beq  +
-         	dey
		sta  (P8ZP_SCRATCH_W1),y
		bne  -

+           	rts
_save_reg	.byte  0
		.pend


memsetw		.proc
	; -- fill memory from (P8ZP_SCRATCH_W1) number of words in P8ZP_SCRATCH_W2, with word value in AY.
	;    clobbers A, X, Y
		sta  _mod1+1                    ; self-modify
		sty  _mod1b+1                   ; self-modify
		sta  _mod2+1                    ; self-modify
		sty  _mod2b+1                   ; self-modify
		ldx  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_B1
		ldx  P8ZP_SCRATCH_W1+1
		inx
		stx  P8ZP_SCRATCH_REG                ; second page

		ldy  #0
		ldx  P8ZP_SCRATCH_W2+1
		beq  _lastpage

_fullpage
_mod1           lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
_mod1b		lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  P8ZP_SCRATCH_W2
		beq  _done

		ldy  #0
-
_mod2           lda  #0                         ; self-modified
                sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  _mod2b
		inc  P8ZP_SCRATCH_W1+1
_mod2b          lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+               dex
		bne  -
_done		rts
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		bne  -
		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
_arg_s1		.word  0
_arg_s2		.word  0
		.pend

strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
		;      Returns -1,0,1 in A, depeding on the ordering. Clobbers Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		lda  (P8ZP_SCRATCH_W2),y
		bne  _return_minusone
		beq  _return
+		cmp  (P8ZP_SCRATCH_W2),y
		bcc  _return_minusone
		bne  _return_one
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		inc  P8ZP_SCRATCH_W2
		bne  _loop
		inc  P8ZP_SCRATCH_W2+1
		bne  _loop
_return_one
		lda  #1
_return		rts
_return_minusone
		lda  #-1
		rts
		.pend


strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y. Clobbers A.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: P8ZP_SCRATCH_W1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (P8ZP_SCRATCH_W1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_wordarray	.proc
	; -- check if a value exists in a word array.
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: address of the word array, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  P8ZP_SCRATCH_W1
		cmp  (P8ZP_SCRATCH_W2),y
		bne  +
		lda  P8ZP_SCRATCH_W1+1
		iny
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
		dey
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend


arraycopy_split_to_normal_words .proc
	; P8ZP_SCRATCH_W1 = start of lsb array
	; P8ZP_SCRATCH_W2 = start of msb array
	; AY = start of normal word target array
	; X = number of elements to copy
                sta  _modlsb+1
                sty  _modlsb+2
                clc
                adc  #1
                bne  +
                iny
+               sta  _modmsb+1
                sty  _modmsb+2
                ldy  #0
-               lda  (P8ZP_SCRATCH_W1),y
_modlsb         sta  $ffff       ; modified lsb store
                lda  _modlsb+1
                clc
                adc  #2
                sta  _modlsb+1
                bcc  +
                inc  _modlsb+2
+               lda  (P8ZP_SCRATCH_W2),y
_modmsb         sta  $ffff       ; modified msb store
                lda  _modmsb+1
                clc
                adc  #2
                sta  _modmsb+1
                bcc  +
                inc  _modmsb+2
+               iny
                dex
                bne  -
		rts
		.pend


arraycopy_normal_to_split_words .proc
	; P8ZP_SCRATCH_W1 = start of target lsb array
	; P8ZP_SCRATCH_W2 = start of target msb array
	; AY = start of normal word source array
	; X = number of elements to copy
		sta  _modsrclsb+1
		sty  _modsrclsb+2
		clc
		adc  #1
		bne  +
		iny
+		sta  _modsrcmsb+1
		sty  _modsrcmsb+2
		ldy  #0
_modsrclsb      lda  $ffff      ; modified lsb read
		sta  (P8ZP_SCRATCH_W1),y
		lda  _modsrclsb+1
		clc
		adc  #2
		sta  _modsrclsb+1
		bcc  +
		inc  _modsrclsb+2
+
_modsrcmsb      lda  $ffff      ; modnfied msb read
		sta  (P8ZP_SCRATCH_W2),y
		lda  _modsrcmsb+1
		clc
		adc  #2
		sta  _modsrcmsb+1
		bcc  +
		inc  _modsrcmsb+2
+		iny
		dex
		bne  _modsrclsb
		rts
		.pend

memcopy_small   .proc
		; copy up to a single page (256 bytes) of memory.
		; note: only works for NON-OVERLAPPING memory regions!
		; P8ZP_SCRATCH_W1 = from address
		; P8ZP_SCRATCH_W2 = destination address
		; Y = number of bytes to copy  (where 0 means 256)
		cpy  #0
		beq  _fullpage
		dey
		beq  _lastbyte
_loop           lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                dey
                bne  _loop
_lastbyte       lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                rts
_fullpage       lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                dey
                bne  _fullpage
                rts
		.pend
; ---- builtin functions


func_any_b_into_A	.proc
		; -- any(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  _got_any
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #0
		rts
_got_any	lda  #1
		rts
		.pend


func_all_b_into_A	.proc
		; -- all(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _got_not_all
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
_got_not_all	rts
		.pend

func_any_w_into_A	.proc
		asl  a
		jmp  func_any_b_into_A
		.pend

func_all_w_into_A	.proc
		; -- all(warray),  array in P8ZP_SCRATCH_W1, num bytes in A
		asl  a			; times 2 because of word
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		bne  ++
		lda  #0
		rts
+		iny
+		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
		rts
		.pend

abs_b_into_A	.proc
	; -- A = abs(A)
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		beq  _possibly_zero
		bmi  _neg
_pos		lda  #1
		rts
_neg		lda  #-1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend


func_sqrt16_into_A	.proc
		; integer square root
		; http://6502org.wikidot.com/software-math-sqrt
		; https://github.com/TobyLobster/sqrt_test/blob/main/sqrt/sqrt7.a
		; Tweaked by TobyLobster and 0xC0DE to be smaller and faster
_numl = P8ZP_SCRATCH_W1
_numh = P8ZP_SCRATCH_W1+1
_loop_counter = P8ZP_SCRATCH_REG
_root = P8ZP_SCRATCH_B1
            sta  _numl
            sty  _numh
            ldx  #$ff
            stx  _loop_counter
            inx
            stx  _root
            sec
_loop       lda  _numh
            sbc  #$40
            tay
            txa
            sbc  _root
            bcc  +
            sty  _numh
            bcs  ++
+           txa
+           rol  _root
            asl  _numl
            rol  _numh
            rol  a
            asl  _numl
            rol  _numh
            rol  a
            tax
            lsr  _loop_counter
            bne  _loop
            lda  _root
            rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in S
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bcc  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bmi  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		cmp  P8ZP_SCRATCH_W2+1
		bne  +
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_right = P8ZP_SCRATCH_W2
_index_left = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_left
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_right
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_left
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_first = P8ZP_SCRATCH_W2
_index_second = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peekw   .proc
	; -- read the word value on the address in AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	pha
	iny
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend


func_clamp_byte .proc
	; signed value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	tay
	sec
	sbc  P8ZP_SCRATCH_W1+1
	bvc  +
	eor  #$80
+       bmi  +
	lda  P8ZP_SCRATCH_W1+1
	tay
	jmp  ++
+       tya
+	sec
	sbc  P8ZP_SCRATCH_W1
	bvc  +
	eor  #$80
+       bmi  +
	tya
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend


func_clamp_ubyte .proc
	; value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	cmp  P8ZP_SCRATCH_W1+1
	bcc  +
	lda  P8ZP_SCRATCH_W1+1
+       cmp  P8ZP_SCRATCH_W1
	bcc  +
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_word .proc
	; signed value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_W2+1
	lda  P8ZP_SCRATCH_W2
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_uword .proc
	; value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	cpy  P8ZP_SCRATCH_W2+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W2
	bcc  ++
+       beq  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	cpy  P8ZP_SCRATCH_W1+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W1
	bcc  ++
+       beq  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts

	.pend
	.pend
; global float constants
; expression temp vars
	.section BSS
	.send BSS
; bss sections
PROG8_VARSHIGH_RAMBANK = 1
prog8_bss_section_start
	.dsection BSS
prog8_bss_section_size = * - prog8_bss_section_start
	.dsection slabs_BSS
prog8_program_end	; end of program label for progend()
